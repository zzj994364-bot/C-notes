https://codeforces.com/problemset/problem/1514/B

## AND 0, Sum Big

Baby Badawy 的第一句话是 “AND 0 SUM BIG”，所以他决定解决下面这个问题。给定两个整数 n 和 k，统计长度为 n 的数组数量，使得：

- 数组中的每个元素都是 0 到 2^k − 1 之间的整数（包含端点）；
- 所有元素的按位与的结果为 0；
- 所有元素之和尽可能大。

因为答案可能非常大，请输出答案对 10^9 + 7 取模后的结果。

### **输入**

第一行包含整数 t (1 ≤ t ≤ 10) —— 测试用例的数量。

每个测试用例由一行组成，包含两个整数 n 和 k (1 ≤ n ≤ 10^5, 1 ≤ k ≤ 20)。

### **输出**

对每个测试用例，输出满足条件的数组数量。因为答案可能非常大，请输出答案对 10^9 + 7 取模后的值。

### **示例**

输入：

```
2
2 2
100000 20
```

输出：

```
4
226732710
```

### **说明**

第一个测试中，这 4 个数组是：

[3, 0]
 [0, 3]
 [1, 2]
 [2, 1]















## 解题思路

我们先从一个数组开始，其中每个元素的每一位(bit)都是 1。
 显然，它的按位与不等于 0，所以对每一位来说，我们需要在至少一个元素中把这一位关掉（变成 0）。

但是，我们不能在多个元素中同时把同一位关掉，因为那样只会无意义地减少总和。
 因此，对于每一位，我们应该**恰好选择一个元素**并在那个元素里关掉这一位。

由于有 k 个比特位和 n 个元素，所以答案就是 **n^k**。



## 代码实现

```cpp
#include <iostream>
using namespace std;

int main () {
    int m = 1e9 + 7;

    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        long long res = 1;
        for (int i = 0; i < k; i++) {
            res = (res * n) % m;
        }
        cout << res << '\n';
    }

    return 0;
}
```



