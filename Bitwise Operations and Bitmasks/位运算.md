# 位运算 (Bit Manipulation)

## 基础

位运算（Bit Manipulation）是直接对整数在内存中的二进制位进行操作的技巧。由于位运算直接在硬件层面执行，速度非常快。它在性能优化、状态压缩、集合操作等方面有广泛应用。

核心运算符（注意位运算的**优先级** ）：

  * `&` (AND): 按位与
  * `|` (OR): 按位或
  * `^` (XOR): 按位异或         **书面表达中 ^ 代表次方， cpp中代表异或运算**
  * `~` (NOT): 按位取反
  * `<<` (Left Shift): 左移，相当于乘以 2
  * `>>` (Right Shift): 右移，相当于除以 2

| a | b | a \& b | a \| b | a \^ b |
|:---:|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 0 | 1 | 1 |
| 1 | 0 | 0 | 1 | 1 |
| 1 | 1 | 1 | 1 | 0 |
- `&`、`|`、`^`满足**交换律**，`a op b == b op a` (操作数的顺序不影响结果)
- `&`、`|`、`^`满足**结合律**，`(a op b) op c == a op (b op c)` (多个操作时，运算的先后顺序不影响结果)

常见应用：

  * **状态压缩**: 将一个集合或bool数组的状态压缩到一个整数中进行表示，常用于“位掩码动态规划”(Bitmask DP)。
  * **高效运算**: 代替部分算术运算，如 `x * 2` (`x << 1`), `x / 2` (`x >> 1`), `x % 2` (`x & 1`)。
  * **集合操作**: 将整数的每一位看作一个元素，`|` 对应并集，`&` 对应交集，`^` 对应对称差。

时间复杂度：单个位运算操作为 $O(1)$。
- 涉及遍历所有位的算法（如统计1的个数）复杂度为 $O(\log N)$ 或 $O(k)$（k为位数）。

空间复杂度： $O(1)$。

## 常用技巧与模板

位运算更像一个工具箱，由许多独立的小技巧组成，而不是一个有固定流程的算法。

### 判断奇偶 (Check Parity)

利用二进制末位是0（偶数）还是1（奇数）的特性。

```cpp
// 如果 n 是偶数，返回 true；否则返回 false
bool isEven(int n) {
    // 偶数的二进制末位是 0
    return (n & 1) == 0;
}
```

### 获取/检查第 k 位 (Get/Check the k-th bit)

检查数字 `n` 从右边数第 `k` 位（从0开始）是否为1。

```cpp
// 如果 n 的第 k 位是 1，返回 true；否则返回 false
bool getBit(int n, int k) {
    // 将 n 右移 k 位，让第 k 位移动到最右边，再和 1 进行与操作
    return (n >> k) & 1;
}
```

### 设置第 k 位为 1 (Set the k-th bit)

将数字 `n` 的第 `k` 位置为 1，其他位不变。

```cpp
// 返回将 n 的第 k 位置为 1 后的结果
int setBit(int n, int k) {
    // 1 左移 k 位得到一个第 k 位是 1 的数，再和 n 进行或操作
    return n | (1 << k);
}
```

### 清除第 k 位为 0 (Clear the k-th bit)

将数字 `n` 的第 `k` 位置为 0，其他位不变。

```cpp
// 返回将 n 的第 k 位置为 0 后的结果
int clearBit(int n, int k) {
    // 1 左移 k 位后取反，得到一个只有第 k 位是 0 的数，再和 n 进行与操作
    return n & (~(1 << k));
}
```

### 翻转第 k 位 (Flip the k-th bit)

将数字 `n` 的第 `k` 位翻转（0变1，1变0）。

```cpp
// 返回将 n 的第 k 位翻转后的结果
int flipBit(int n, int k) {
    // 1 左移 k 位得到一个第 k 位是 1 的数，再和 n 进行异或操作
    return n ^ (1 << k);
}
```

### `lowbit` - 获取最低位的 1

获取 `n` 的二进制表示中，最低位的 `1` 以及它后面的 `0` 组成的数值。

```cpp
// 返回 n 的 lowbit 值
int lowbit(int n) {
    // n 和它的相反数进行与操作
    // 原理: n 的相反数等于 ~n + 1
    return n & (-n);
}
```

### `popcount` - 统计 1 的个数

统计 `n` 的二进制表示中 `1` 的数量。

```cpp
// 返回 n 的二进制表示中 1 的个数
int popcount(int n) {
    int count = 0;
    while (n > 0) {
        // 每次减去 lowbit，相当于消去最低位的 1
        n -= lowbit(n);
        count++;
    }
    return count;
    // 注：在竞赛或性能要求高的场景，通常使用内置函数：
    // return __builtin_popcount(n); // (GCC/Clang)
}
```

### 判断是否为 2 的幂

一个数如果是 2 的幂，那么它的二进制表示中只有一个 `1`。

```cpp
// 如果 n 是 2 的幂，返回 true
bool isPowerOfTwo(int n) {
    // n > 0 排除 0 的情况
    // n & (n - 1) 可以清除 n 最低位的 1。如果结果为 0，说明 n 只有一个 1。
    return n > 0 && (n & (n - 1)) == 0;
}

// 其他方法：
// lowbit(n) == n 
// popcount(n) == 1 
```

### 遍历一个状态的所有子集

高效遍历一个二进制掩码（mask）所代表集合的所有子集。

```cpp
#include <iostream>

// 遍历 mask 的所有子集
void iterateSubsets(int mask) {
    // sub 从 mask 开始，每次迭代都变成 mask 的下一个子集
    // (sub - 1) & mask 这个操作会巧妙地生成下一个字典序更小的子集
    for (int sub = mask; sub > 0; sub = (sub - 1) & mask) {
        // 在这里处理子集 sub
        cout << sub << endl;
    }
}
```

## 异或技巧
二进制翻转、重复数字

### 异或基础
```cpp
// 0 的 异或保持原数不变
0 ^ 0 == 0 // 0保持不变
0 ^ 1 == 1 // 1保持不变

// 1 的 异或翻转原数
1 ^ 0 == 1 // 0翻转
1 ^ 1 == 0 // 1翻转

// 相同数字异或结果为0
x ^ x == 0 // 123 ^ 123 == 0
x ^ x ^ x == x // 123 ^ 123 ^ 123 == 123
```

### 使用异或交换整数
```cpp
// 交换整数 x 和 y
x ^= y; // x 为 x ^ y
y ^= x; // y 为 y ^ x ^ y 结果为 x
x ^= y; // x 为 x ^ y ^ x 结果为 y
```

### 找一个丢失的元素
无序序列 `a` 由 `n-1` 个元素组成。对于无序数列`a`，其元素值由 `1` 到 `n` 组成，并且没有重复。找出这个丢失的元素（`[1, n]`）。
```cpp
// 利用 x ^ x = 0，异或满足交换律和结合律 可解
// 1 ^ 2 ^ ... ^ n ^ a[0] ^ a[1] ^ ... ^ a[n - 2]
int result = 0;
// 对 1 至 n 进行异或
for (int i = 1; i <= n; i++) {
    result ^= i;
}

// 对 每一个 a[i] 进行异或
for (int i = 0; i < a.size(); i++) { // n - 1 个元素
    result ^= a[i];
}

cout << result;

// 方法二：加法和减法
// 通过 1 + 2 + ... + n - a[0] - a[1] - ... - a[n - 2]
```

### 找两个丢失的元素
问题同上，不过丢失了2个元素。
1. 设缺失的两个数为 `u` 与 `v`。把输入数组全部异或，再与 `1..n` 的异或值再异或，得到
   `x = u ^ v`。
2. 取 `x` 的某个为 1 的位（通常取最低位 1）：`flag = x & -x`。这说明 `u` 与 `v` 在该位上不同。
3. 按 `flag` 的值把所有数字（包含数组里的数，及 `1..n`）分成两组，然后分别异或；由于其余数字在两边各自配对抵消，最终两组的异或结果就是 `u` 与 `v`。

```cpp
// 1) 得到 x = u ^ v
int xor_all = 0; // u ^ v
for (int i = 1; i <= n; i++) {
    xor_all ^= i;
}
for (int i = 0; i < a.size(); i++) { // n - 2 个元素
    xor_all ^= a[i];
}

// 2) 取最低位 1（u 与 v 在该位上不同）
int flag = xor_all & (-xor_all);

// 3) 分两组异或：数组与 1..n 都参与分组
int group_xor_a = 0, group_xor_b = 0;
for (int i = 0; i < a.size(); ++i) { // 对数组 a 进行分组
    if (a[i] & flag) {
        group_xor_a ^= a[i];
    } else {
        group_xor_b ^= a[i];
    }
}
for (int i = 1; i <= n; ++i) { // 对 1 到 n 进行分组
    if (i & flag) {
        group_xor_a ^= i;
    } else {
        group_xor_b ^= i;
    }
}

// 现在 group_xor_a 与 group_xor_b 就是两个缺失数（顺序未知）
cout << group_xor_a << group_xor_b;
```


## 内建函数

GCC 中还有一些用于位运算的内建函数。

由于这些函数是内建函数，经过了编译器的高度优化，运行速度十分快（有些甚至只需要一条指令）。
```cpp
// 返回 x 的二进制末尾最后一个 1 的位置，位置的编号从 1 开始（最低位编号为 1）。当 x 为 0 时返回 0。
int __builtin_ffs(int x)

// 返回 x 的二进制的前导 0 的个数。当 x 为 0 时，结果未定义。
int __builtin_clz(unsigned int x)

// 返回 x 的二进制末尾连续 0 的个数。当 x 为 0 时，结果未定义。
int __builtin_ctz(unsigned int x)

// 当 x 的符号位为 0 时返回 x 的二进制的前导 0 的个数减一，否则返回 x 的二进制的前导 1 的个数减一。
int __builtin_clrsb(int x)

// 返回 x 的二进制中 1 的个数。
int __builtin_popcount(unsigned int x)

// 判断 x 的二进制中 1 的个数的奇偶性。
int __builtin_parity(unsigned int x)
```

- 这些函数都可以在函数名末尾添加 `l` 或 `ll` （如 `__builtin_popcountll` ）来使参数类型变为 ( `unsigned` ) `long` 或 ( `unsigned` ) `long long` （返回值仍然是 `int` 类型）。

例如，我们有时候希望求出一个数以二为底的对数，如果不考虑 `0` 的特殊情况，就相当于这个数二进制的位数 `-1` ，而一个数 `n` 的二进制表示的位数可以使用 `32-__builtin_clz(n)` 表示，因此 `31-__builtin_clz(n)` 就可以求出 `n` 以二为底的对数。
