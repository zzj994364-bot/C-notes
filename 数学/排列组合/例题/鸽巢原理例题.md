https://codeforces.com/problemset/problem/1305/C

## Kuroni 和不可能的计算

为了成为 Codeforces 的王者，Kuroni 需要解决下面这个问题。

给定 n 个数 a₁, a₂, …, aₙ。请帮助 Kuroni 计算
 $\prod_{1 \le i < j \le n} |a_i - a_j|$。
 由于结果可能非常大，请输出结果对 m 取模后的值。

如果你对简写不熟悉，
 $\prod_{1 \le i < j \le n} |a_i - a_j|$
 等于
 |a₁−a₂|·|a₁−a₃|·…·|a₁−aₙ|·|a₂−a₃|·|a₂−a₄|·…·|a₂−aₙ|·…·|aₙ₋₁−aₙ|。
 换句话说，就是对所有 1 ≤ i < j ≤ n 的 |aᵢ − aⱼ| 的乘积。

------

**输入**

第一行包含两个整数 n, m（2 ≤ n ≤ 2⋅10⁵, 1 ≤ m ≤ 1000）——数字数量和模数。

第二行包含 n 个整数 a₁, a₂, …, aₙ（0 ≤ aᵢ ≤ 10⁹）。

------

**输出**

输出一个整数：$\prod_{1 \le i < j \le n} |a_i - a_j| \mod m$。

------

**样例**

输入
 2 10
 8 5
 输出
 3

输入
 3 12
 1 4 5
 输出
 0

输入
 3 7
 1 4 9
 输出
 1















## 解题思路

这题巧妙地利用鸽笼原理将一个看似复杂的计算问题转化为:

- **n > m**: O(1) 直接输出 0
- **n ≤ m**: O(n²) 暴力计算

**在这道题中的映射**

 1. 识别"鸽子"和"鸽笼"

- **鸽子**: n 个数 a₁, a₂, ..., aₙ (共 n 只"鸽子")
- **鸽笼**: 模 m 的所有可能余数 {0, 1, 2, ..., m-1} (共 m 个"鸽笼")

 2. 建立映射关系

每个数 aᵢ 通过取模运算 `aᵢ mod m` 被放入对应的"鸽笼"中。

例如,如果 m = 5:

- a₁ = 7 → 7 mod 5 = 2 → 放入"鸽笼2"
- a₂ = 13 → 13 mod 5 = 3 → 放入"鸽笼3"
- a₃ = 12 → 12 mod 5 = 2 → 放入"鸽笼2"

 3. 应用鸽笼原理

**当 n > m 时:**

- 有 n 个数(鸽子)
- 只有 m 个可能的余数(鸽笼)
- 根据鸽笼原理:**必然存在至少两个数 aᵢ 和 aⱼ,它们模 m 的余数相同**

 **数学推导**

 步骤1: 同余的含义

如果 aᵢ ≡ aⱼ (mod m),即:

```
aᵢ mod m = aⱼ mod m
```

这意味着:

```
aᵢ - aⱼ ≡ 0 (mod m)
```


 步骤2: 差值是 m 的倍数

由 `aᵢ - aⱼ ≡ 0 (mod m)` 可知:

```
aᵢ - aⱼ = k·m  (k 是某个整数)
```

因此:

```
|aᵢ - aⱼ| = |k·m| = |k|·m
```


 步骤3: 乘积中包含 m 的倍数

题目要求的乘积是:

```
∏(1≤i<j≤n) |aᵢ - aⱼ| mod m
```

这个乘积中包含因子 `|aᵢ - aⱼ|`,而我们已经证明 `|aᵢ - aⱼ|` 是 m 的倍数。



 步骤4: 最终结论

```
∏(1≤i<j≤n) |aᵢ - aⱼ| = (...) · |aᵢ - aⱼ| · (...)
                       = (...) · (|k|·m) · (...)
                       = m · (...)
                       ≡ 0 (mod m)
```

 **具体例子验证**

**例子**: n = 6, m = 5, 数组 = [3, 8, 13, 7, 12, 18]

计算每个数模 5 的余数:

- 3 mod 5 = 3 → 鸽笼3
- 8 mod 5 = 3 → 鸽笼3 ✓ (重复!)
- 13 mod 5 = 3 → 鸽笼3 ✓ (重复!)
- 7 mod 5 = 2 → 鸽笼2
- 12 mod 5 = 2 → 鸽笼2 ✓ (重复!)
- 18 mod 5 = 3 → 鸽笼3 ✓ (重复!)

因为 n = 6 > m = 5,鸽笼原理保证至少有一对数同余。

实际上:

- |3 - 8| = 5 ≡ 0 (mod 5)
- |3 - 13| = 10 ≡ 0 (mod 5)
- |7 - 12| = 5 ≡ 0 (mod 5)

乘积中任何一个因子是 0,整个乘积就是 0。



## 代码实现

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    //当n > m符合鸽巢定理
    if (n > m) {
        cout << 0 << endl;
        return 0;
    }

    vector<int> v(n);
    for (int i = 0; i < n; i++) cin >> v[i];

    //此时数据量特别小（n <= m, m <= 1000),暴力计算,时间复杂度为O(n^2)
    long long res = 1;
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            int temp = abs(v[i] - v[j]);
            res = res * temp % m;
        }
    }

    cout << res << endl;

    return 0;
}
```

