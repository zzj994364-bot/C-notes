https://codeforces.com/contest/57/problem/C

# Array

Chris 小兔子一直对数组很感兴趣。现在他正在研究 **长度为 n、且只包含 1 到 n 的整数** 的数组。

但他数学不好，有些简单的事情都会把他逼疯。昨天他突然想数一数：

> **有多少个不同的「漂亮数组」？**

Chris 认为一个数组是漂亮的，如果满足下面两个条件中的**任意一个**：

1. **从第二个元素开始，每个元素都不大于前一个元素**
    — 也就是整个数组是 **非递增** 的。
2. **从第二个元素开始，每个元素都不小于前一个元素**
    — 也就是整个数组是 **非递减** 的。

Chris 被这个问题搞疯了，于是找 Stewie 和 Brian。但他们只嘲笑他说答案太简单了。

请你帮 Chris 找到答案。

------

## **输入格式**

一行，一个整数 n，表示数组长度。
 (1 ≤ n ≤ 100000)

------

## **输出格式**

输出漂亮数组的数量，结果对 1,000,000,007 取模。

------

## **样例**

**输入：**

```
2
```

**输出：**

```
4
```

**输入：**

```
3
```

**输出：**

```
17
```

















## 解题思路

这是一个**stars and bars 的变体**

#### 关键观察

事实上**排序根本不重要**，因为我们要构造的是**非递增/非递减数组**，一旦确定了"用哪些数字，每个数字用几次"，排序方式就**唯一确定**了：

```
选择方案：用了 3 个 1，2 个 3，1 个 5

非递减排列（唯一）：[1, 1, 1, 3, 3, 5]
非递增排列（唯一）：[5, 3, 3, 1, 1, 1]
```

#### 问题转化

**原问题**：统计满足单调性的数组 ⬇️ **转化为**：统计"多重集"的个数

- **多重集**：{1出现x₁次, 2出现x₂次, ..., n出现xₙ次}，其中 x₁ + x₂ + ... + xₙ = n

#### 重复组合公式

从 n 种元素中可重复地选 n 个的方案数 = **C(n + n - 1, n) = C(2n - 1, n)**

这就是经典的"**隔板法**"或"**星星和棒子**"问题：

- n 个球（数组的 n 个位置）
- n 个盒子（数字 1 到 n）
- 球可重复放入任意盒子
- 允许盒子为空

## 代码实现

```cpp
//2 * C(2 * n - 1, n) - n = res
#include <iostream>
using namespace std;

const int MAXN = 200000;               //填入n的最大值
const int MOD = 1000000007;      //填入mod值（通常为1e9 + 7)

//定义阶乘和阶乘逆元的数组
long long fac[MAXN + 1], invfac[MAXN + 1]; //用long long定义

//快速幂
long long power(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1) {
            result = (result * base) % mod;
        }
        exp >>= 1;
        base = (base * base) % mod;
    }
    return result;
}

int main() {
    //阶乘预处理
    fac[0] = 1;
    for (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;
    
    //阶乘逆元预处理
    invfac[MAXN] = power(fac[MAXN], MOD - 2, MOD);
    for (int i = MAXN - 1; i >= 0; i--) 
            invfac[i] = invfac[i + 1] * (i + 1) % MOD;

    int n;
    cin >> n;
    
    long long res = 2;
    res = res * fac[2 * n - 1] % MOD * invfac[n] % MOD * invfac[n - 1] % MOD - n;

    cout << res << endl;

    return 0;
}
```

