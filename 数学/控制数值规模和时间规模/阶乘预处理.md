## 阶乘预处理 (Factorial Precomputation)

### 核心目的

在算法竞赛或需要大量计算组合数 $\binom{n}{k}$ 的场景中，如果模数 $P$ 是一个质数，我们通常需要计算 $\binom{n}{k} \pmod{P}$。

由于 $\binom{n}{k} = \frac{n!}{k! (n-k)!}$ 涉及除法，而模运算中没有直接除法，我们必须将其转换为乘法：

$$\binom{n}{k} \equiv n! \cdot (k!)^{-1} \cdot ((n-k)!)^{-1} \pmod{P}$$

其中 $(k!)^{-1}$ 和 $((n-k)!)^{-1}$ 分别是 $k!$ 和 $(n-k)!$ 关于模 $P$ 的模逆元。

阶乘预处理的目的就是：**提前计算所有需要的阶乘值 $n!$ 和它们的模逆元 $(n!)^{-1}$，以便在 $O(1)$ 时间内快速计算任意组合数。**



**反例**：

问题给出t个测试用例，每个测试用例给一个n，求n！

直接求n!的时间复杂度为**O(n^2)**会导致超时，所以读入测试用例前**预处理 n 到 MAX_n 的fac**

### 1. 预处理内容

我们需要预先计算两个数组，假设最大需要计算到 $N$ 的阶乘：

1. 阶乘数组 (Factorials Array)： 存储 $i! \pmod{P}$ 的值。

   

   $$\text{fact}[i] = i! \pmod{P}$$

2. 阶乘逆元数组 (Inverse Factorials Array)： 存储 $(i!)^{-1} \pmod{P}$ 的值。

   

   $$\text{invfact}[i] = (i!)^{-1} \pmod{P}$$

### 2. 预处理步骤（$O(N + \log P)$ 时间复杂度）

#### 步骤 1: 计算阶乘数组 $\text{fact}[i]$ ($O(N)$)

这是最简单的部分，使用递推关系计算：

$$\text{fact}[i] = \text{fact}[i-1] \cdot i \pmod{P}$$

- **初始化：** $\text{fact}[0] = 1$
- **计算：** 从 $i=1$ 递推到 $N$。

| **代码实现 (伪代码)**                                     |
| --------------------------------------------------------- |
| $\text{fact}[0] = 1;$                                     |
| $\text{for } i = 1 \text{ to } N:$                        |
| $\quad \text{fact}[i] = (\text{fact}[i-1] * i) \pmod{P};$ |

#### 步骤 2: 计算最大阶乘逆元 $\text{invfact}[N]$ ($O(\log P)$)

这是整个预处理中唯一需要使用对数时间复杂度的求逆元操作。由于 $P$ 是质数，我们使用**费马小定理**配合**快速幂**来计算 $N!$ 的模逆元。

$$\text{invfact}[N] = (N!)^{-1} \equiv (N!)^{P-2} \pmod{P}$$

- **求解：** 使用快速幂计算 $\text{pow}(\text{fact}[N], P-2, P)$。

| **代码实现 (伪代码)**                                     |
| --------------------------------------------------------- |
| $\text{invfact}[N] = \text{pow}(\text{fact}[N], P-2, P);$ |

#### 步骤 3: 递推计算其他阶乘逆元 $\text{invfact}[i]$ ($O(N)$)

一旦我们求出了最大的阶乘逆元 $\text{invfact}[N] = (N!)^{-1}$，就可以利用递推关系**倒序**计算出所有其他的逆元，而**无需**再次进行快速幂，从而将这部分的复杂度降到 $O(N)$。

我们知道：


\[
i! = (i+1)! / (i+1)
\]


对其取模逆元：


\[
(i!)^{-1} \equiv \left(\frac{i+1}{(i+1)!}\right)^{} \pmod{P}
\]


\[
(i!)^{-1} \equiv ((i+1)!)^{-1} \cdot (i+1) \pmod{P}
\]


所以，递推公式为：



$$\text{invfact}[i] = \text{invfact}[i+1] \cdot (i+1) \pmod{P}$$



- **计算：** 从 $i=N-1$ 倒序递推到 $0$。

| **代码实现 (伪代码)**                                        |
| ------------------------------------------------------------ |
| $\text{for } i = N-1 \text{ down to } 0:$                    |
| $\quad \text{invfact}[i] = (\text{invfact}[i+1] * (i+1)) \pmod{P};$ |

### 3. 最终组合数计算 ($O(1)$)

完成预处理后，计算任意 $\binom{n}{k} \pmod{P}$ 只需要一次乘法和两次逆元乘法，时间复杂度为 $O(1)$：

$$\binom{n}{k} \pmod{P} \equiv \text{fact}[n] \cdot \text{invfact}[k] \cdot \text{invfact}[n-k] \pmod{P}$$

| **代码实现 (伪代码)**                                        |
| ------------------------------------------------------------ |
| $\text{def choose}(n, k, P):$                                |
| $\quad \text{if } k < 0 \text{ or } k > n: \text{ return } 0$ |
| $\quad \text{return } (\text{fact}[n] * \text{invfact}[k] * \text{invfact}[n-k]) \pmod{P}$ |

### 总结

阶乘预处理是解决**模意义下组合计数问题**的**标准范式**。它将大量的 $O(\log P)$ 模逆元运算（通过快速幂）转换成了单一的 $O(\log P)$ 计算，加上 $O(N)$ 的线性预处理，使得后续的每次查询都能在**常数时间** $O(1)$ 内完成。





### 代码模板

```cpp
const int MAXN = ;               //填入n的最大值
const int MOD = 1000000007;      //填入mod值（通常为1e9 + 7)

//定义阶乘和阶乘逆元的数组
long long fac[MAXN + 1], invfac[MAXN + 1]; //用long long定义

//快速幂
long long power(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1) {
            result = (result * base) % mod;
        }
        exp >>= 1;
        base = (base * base) % mod;
    }
    return result;
}

int main() {
    //阶乘预处理
    fac[0] = 1;
    for (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;
    
    //阶乘逆元预处理
    invfac[MAXN] = power(fac[MAXN], MOD - 2, MOD);
    for (int i = MAXN - 1; i >= 0; i--) invfac[i] = invfac[i + 1] * (i + 1) % MOD;
}
```

