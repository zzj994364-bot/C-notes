## **题目翻译**

给你一个 **1-indexed（从 1 开始）** 的数组，初始所有元素都是 **0**。
 接着给你若干条操作，每条操作包含三个整数：

```
a  b  k
```

表示：把数组下标 **从 a 到 b（包含）** 的所有元素都 **加上 k**。

在执行完所有操作之后，请你返回数组中的 **最大值**。

------

### **例子解释**

给定操作：

```
1 5 3
4 8 7
6 9 1
```

表示：

- 第 1 条操作：给区间 [1,5] 的所有数加 3
- 第 2 条操作：给区间 [4,8] 的所有数加 7
- 第 3 条操作：给区间 [6,9] 的所有数加 1

最终数组的最大值是操作全部执行后得到的最大数字。

------

### **函数说明**

你需要完成一个函数：

```
arrayManipulation(n, queries)
```

- `n`：数组长度
- `queries[i] = [a, b, k]`

返回执行所有操作后的数组最大值。

------

### **输入格式**

第一行：两个整数 n 和 q
 接下来 q 行：每行三个整数 `a b k`

------

### **样例输入**

```
5 3
1 2 100
2 5 100
3 4 100
```

------

### **样例输出**

```
200
```

------

### **解释**

- 操作 1：把 [1,2] 各加 100 → `100 100 0 0 0`
- 操作 2：把 [2,5] 各加 100 → `100 200 100 100 100`
- 操作 3：把 [3,4] 各加 100 → `100 200 200 200 100`

最大值 = **200**













## 代码实现

**注意r + 1越界问题**

```cpp
#include <iostream>
#include <vector>
using ll = long long;
using namespace std;

int main () {
    int n, q;
    cin >> n >> q;

    vector<ll> v(n + 2); //大小定为n + 2防止越界
    
    //差分标记
    for (int i = 0; i < q; i++) {
        ll a, b, k;
        cin >> a >> b >> k;
        v[a]+= k;
        v[b + 1]-= k;
    }

    //前缀和还原
    for (int i = 1; i <= n; i++) {
        v[i] += v[i - 1];
    }

    ll biggest = -1;
    for (auto x : v) {
        biggest = max(biggest, x);
    }

    cout << biggest << endl;

    return 0;

}
```

