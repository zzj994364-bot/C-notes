# 递归 (Recursion)

## 基础

递归是一种解决问题的强大方法，其中一个函数直接或间接地调用自身。一个问题如果可以被分解为与原问题结构相同但规模更小的子问题，那么它通常可以用递归来解决。递归思想与数学归纳法密切相关。

任何一个正确的递归算法都必须包含两个核心部分：

1.  **基准情况 (Base Case):** 问题最简单的实例，可以直接求解，无需进一步递归。这是递归的终止条件。
2.  **递归步骤 (Recursive Step):** 将原问题分解为一个或多个规模更小的子问题，并对这些子问题进行递归调用，然后将子问题的解组合起来得到原问题的解。

常见应用：

  * **树与图的遍历**: 深度优先搜索（DFS）的实现，如树的前序、中序、后序遍历。
  * **分治算法**: 递归是分治范式的核心实现机制，例如归并排序、快速排序。
  * **回溯算法**: 在一个大的搜索空间中探索所有可能性，例如 N皇后问题、全排列、子集生成。
  * **数学问题**: 求解阶乘、斐波那契数列（作为教学例子）、最大公约数（欧几里得算法）等。
  * **数据结构定义**: 像树、链表这样的数据结构本身就是递归定义的（一个树节点包含指向其他树节点的指针）。

时间/空间复杂度：

  * **时间复杂度**: 通常等于 **递归调用次数** × **每次调用中的计算量**。可以使用主定理（Master Theorem）或递归树方法进行分析。例如，归并排序是 $O(N \log N)$。
  * **空间复杂度**: 主要由递归调用的最大深度决定，因为每一次函数调用都需要在调用栈（Call Stack）上分配空间。复杂度为 $O(\text{递归深度})$。如果递归深度过大，可能会导致“栈溢出”（Stack Overflow）错误。

## 算法的流程

设计一个递归函数通常遵循以下思维流程：

1.  **定义递归函数**: 明确函数的**功能**、**参数**和**返回值**。例如，`int solve(int n)` 的功能是“计算问题规模为n时的解”。参数 `n` 定义了当前问题的状态和规模。
2.  **确定基准情况 (Base Case)**: 找到一个或多个最简单的情况，此时函数可以直接返回结果，不再进行递归调用。这是递归的“出口”。
3.  **确定递归关系 (Recursive Step)**: 思考如何将当前问题 `solve(n)` 与一个或多个规模更小的子问题（例如 `solve(n-1)`, `solve(n/2)`）联系起来。通过调用自身来解决这些子问题，并利用子问题的解来构造出当前问题的解。

## 算法模板

### 模板一：通用递归结构

这个模板展示了递归函数最核心的组成部分。

```cpp
/**
 * @brief 通用递归函数的结构模板
 * @param state 当前问题的状态或规模 (例如整数、节点指针等)
 * @return 当前状态下的计算结果
 */
ReturnType recursive_function(ProblemState state) {
    // 1. 基准情况 (Base Case): 检查是否满足终止条件
    if (is_base_case(state)) {
        // 如果是，直接计算并返回最简单情况的结果
        return compute_base_case_result(state);
    }

    // 2. 递归步骤 (Recursive Step)
    // a. 将当前问题分解为一个或多个子问题
    SubProblemState sub_state1 = generate_sub_problem1(state);
    SubProblemState sub_state2 = generate_sub_problem2(state);
    // ...

    // b. 对子问题进行递归调用
    SubReturnType sub_result1 = recursive_function(sub_state1);
    SubReturnType sub_result2 = recursive_function(sub_state2);
    // ...
    
    // c. 将子问题的解合并成当前问题的解
    ReturnType current_result = combine_results(sub_result1, sub_result2 /*, ... */);

    return current_result;
}
```

### 模板二：深度优先搜索 (DFS) 遍历

这是递归在图/树遍历中最常见的应用模式。

```cpp
#include <vector>

// 假设 visited 是一个全局或通过引用传递的数组/哈希表，用于记录访问过的节点
// 假设 graph 是邻接表表示的图

/**
 * @brief 深度优先搜索 (DFS) 的递归模板
 * @param u 当前正在访问的节点
 */
void dfs(int u) {
    // 1. 处理当前节点 (前序位置)
    // 例如：标记为已访问，打印节点值等
    visited[u] = true;
    process(u); 

    // 2. 递归步骤：遍历当前节点的所有邻居
    for (int v : graph[u]) {
        // 如果邻居节点 v 未被访问过
        if (!visited[v]) {
            // 对邻居节点进行递归调用
            dfs(v);
        }
    }

    // 3. (可选) 所有子节点都访问完毕后，可以再次处理当前节点 (后序位置)
    // process_after_children(u);

    // 基准情况是隐式的：当一个节点没有未访问的邻居时，
    // for 循环结束，函数自然返回，递归终止。
}
```

### 一些代码模板

```cpp
返回类型 函数名(参数) {
    if (满足终止条件) return 最小问题的答案;  // base case
    return 根据当前问题 + 递归调用(...);       // recursive case
}

//解决阶乘问题
long long factorial(long long n) {
    if (n == 0) return 1;  // base case
    return n * factorial(n - 1); // recursive case
}
//解决斐波那契问题
int fib(int n) {
    if (n == 1) return 0;  // base case 1
    if (n == 2) return 1;  // base case 2
    return fib(n - 1) + fib(n - 2);  // recursive case
}



void printLove(int n) {
    if (n == 0) return; //终止条件
    cout << "I love Recursion" << '\n';
    printLove(n - 1);   //递归调用
}  //正向 ---- 先执行再递归
void print(int n) {
    if (n == 0) return;   // 1️⃣ base case：停止条件
    print(n - 1);         // 2️⃣ 递归调用（先解决更小的子问题）
    cout << n << '\n';    // 3️⃣ 打印当前 n
}  //逆向 ---- 先递归再执行
```

```cpp
// 有返回值的递归
int factorial(int n) {
if (n == 0) return 1;
return n * factorial(n - 1);
}

// 无返回值的递归
void printN(int n) {
if (n == 0) return;
printN(n - 1);
cout << n << " ";
}
```

![](C:\Users\24940\Desktop\C++笔记\Recursion\images\recursion_sum.png)

