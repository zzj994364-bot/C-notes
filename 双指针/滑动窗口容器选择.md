# 滑动窗口容器选择指南

## 决策流程图

```
需要维护什么信息？
│
├─ 只需要计数/求和？
│   └─ 用【变量】即可
│       int count = 0, sum = 0;
│
├─ 需要判断元素是否存在？
│   ├─ 不需要计数 → 用【unordered_set】O(1)
│   └─ 需要计数 → 用【unordered_map/map】O(1) 或 O(log n)
│
├─ 需要维护最大/最小值？
│   ├─ 只在一端添加/删除 → 用【单调队列 deque】O(1)
│   ├─ 两端都要添加/删除 → 用【multiset/map】O(log n)
│   └─ 需要知道第k大 → 用【multiset + 迭代器】O(log n)
│
├─ 需要维护有序性？
│   └─ 用【multiset/set/map】O(log n)
│
└─ 需要保持插入顺序？
    └─ 用【deque/queue】O(1)
```

## 常用容器对比表

| 容器 | 查询 | 插入 | 删除 | 适用场景 |
|------|------|------|------|----------|
| **变量** | O(1) | O(1) | O(1) | 简单计数、求和 |
| **unordered_set** | O(1) | O(1) | O(1) | 判断存在性 |
| **unordered_map** | O(1) | O(1) | O(1) | 频率统计（无序） |
| **map** | O(log n) | O(log n) | O(log n) | 频率统计+需要有序 |
| **multiset** | O(log n) | O(log n) | O(log n) | 维护多重有序集合 |
| **deque** | O(1) | O(1) | O(1) | 单调队列、FIFO |
| **priority_queue** | O(1) | O(log n) | O(log n) | 只需最大/最小值（不支持删除任意元素） |

## 典型问题分类

### 1. 只需要简单统计 → 变量

```cpp
// 例：最长连续子数组，最多包含k个0
int left = 0, zeros = 0, maxLen = 0;
for (int right = 0; right < n; right++) {
    if (a[right] == 0) zeros++;
    while (zeros > k) {
        if (a[left] == 0) zeros--;
        left++;
    }
    maxLen = max(maxLen, right - left + 1);
}
```

**判断标准**：
- ✅ 只统计个数/总和
- ✅ 不需要知道具体元素
- ✅ 条件简单（如：零的个数≤k）

---

### 2. 需要频率统计 → map/unordered_map

```cpp
// 例：最长子串，最多包含k个不同字符
unordered_map<char, int> count;
int left = 0, maxLen = 0;
for (int right = 0; right < n; right++) {
    count[s[right]]++;
    while (count.size() > k) {
        count[s[left]]--;
        if (count[s[left]] == 0) count.erase(s[left]);
        left++;
    }
    maxLen = max(maxLen, right - left + 1);
}
```

**判断标准**：
- ✅ 需要统计每个元素出现次数
- ✅ 需要动态添加/删除元素
- ✅ 不关心元素顺序 → unordered_map
- ✅ 需要有序遍历 → map

---

### 3. 需要维护最大/最小值 → 看删除方式

#### 3a. 固定窗口大小 → 单调队列（deque）

```cpp
// 例：滑动窗口最大值（固定大小k）
deque<int> dq;  // 存储下标，保持递减
vector<int> result;

for (int i = 0; i < n; i++) {
    // 移除窗口外的元素
    while (!dq.empty() && dq.front() <= i - k) 
        dq.pop_front();
    
    // 维护单调性
    while (!dq.empty() && a[dq.back()] <= a[i]) 
        dq.pop_back();
    
    dq.push_back(i);
    
    if (i >= k - 1) 
        result.push_back(a[dq.front()]);
}
```

**判断标准**：
- ✅ 窗口大小固定
- ✅ 只需要最大值或最小值（不是同时需要）
- ✅ 可以用单调性优化

#### 3b. 可变窗口 + 需要max和min → multiset/map

```cpp
// 例：本题 - 最长几乎常量区间
map<int, int> count;
int left = 0, maxLen = 0;
for (int right = 0; right < n; right++) {
    count[a[right]]++;
    
    // 需要同时知道max和min
    while (count.rbegin()->first - count.begin()->first > 1) {
        count[a[left]]--;
        if (count[a[left]] == 0) count.erase(a[left]);
        left++;
    }
    maxLen = max(maxLen, right - left + 1);
}
```

**判断标准**：
- ✅ 窗口大小可变
- ✅ 需要同时维护最大值和最小值
- ✅ 需要频繁删除任意元素
- ✅ 需要O(log n)的有序访问

---

### 4. 需要判断存在性 → set/unordered_set

```cpp
// 例：最长无重复子串
unordered_set<char> window;
int left = 0, maxLen = 0;
for (int right = 0; right < n; right++) {
    while (window.count(s[right])) {
        window.erase(s[left]);
        left++;
    }
    window.insert(s[right]);
    maxLen = max(maxLen, right - left + 1);
}
```

**判断标准**：
- ✅ 只需要判断元素是否在窗口内
- ✅ 不需要统计次数
- ✅ 快速查找 O(1)

---

## 特殊技巧

### 技巧1：利用题目约束优化

```cpp
// 如果值域很小（如只有小写字母），用数组代替map
int count[26] = {0};  // 比 map<char,int> 更快

// 如果窗口内元素种类有限，可以简化判断
if (count.size() > k) { ... }  // 比计算max-min更简单
```

### 技巧2：双指针 vs 滑动窗口

- **双指针**：两个指针独立移动
- **滑动窗口**：右指针扩展，左指针收缩

都可能需要容器维护状态，选择标准相同。

### 技巧3：组合使用

```cpp
// 同时需要频率和顺序
map<int, int> count;           // 维护频率+有序
unordered_map<int, int> pos;  // 维护位置
```

---

## 快速决策清单

**问自己3个问题：**

1. **需要维护什么？**
   - 计数/和 → 变量
   - 存在性 → set
   - 频率 → map
   - 最值 → deque/multiset

2. **访问模式如何？**
   - 只访问最大/最小 → deque/priority_queue
   - 需要遍历/范围查询 → map/multiset
   - 频繁查找 → unordered容器

3. **时间复杂度要求？**
   - O(1) → 变量/unordered容器
   - O(log n) → ordered容器
   - O(n) → 可以接受时考虑简单方案

---

## 练习题推荐

1. **变量**: [至多包含K个不同字符的最长子串](只需计数)
2. **unordered_map**: [最小覆盖子串](频率统计)
3. **map**: [最长连续子序列](需要有序)
4. **deque**: [滑动窗口最大值](单调队列)
5. **multiset**: [包含min(A)的最小窗口](动态最值)

记住：**先分析需要维护的信息，再选择合适的容器！**