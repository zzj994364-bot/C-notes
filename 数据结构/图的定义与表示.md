# 图：定义与表示

## 基础

图（Graph）是一种用于表示对象之间关系的数据结构。它由一组**顶点**（Vertices或Nodes）和一组连接顶点的**边**（Edges）组成。形式化地，一个图 $G$ 可以表示为 $G=(V, E)$，其中 $V$ 是顶点集， $E$ 是边集。

**核心定义与分类**:

  * **无向图 (Undirected Graph)**: 边没有方向。如果顶点 `u` 和 `v` 之间有边，则可以从 `u` 到 `v`，也可以从 `v` 到 `u`。
  * **有向图 (Directed Graph / Digraph)**: 边有方向。边 `(u, v)` 表示一个从 `u` 指向 `v` 的连接，但不能反向。
  * **无权图 (Unweighted Graph)**: 所有边的“成本”或“长度”都相同（通常视为1）。
  * **带权图 (Weighted Graph)**: 每条边都有一个关联的数值（权重），可以代表成本、距离、时间等。
  * **度 (Degree)**:
      * 在无向图中，一个顶点的度是指与它相连的边的数量。
      * 在有向图中，分为**入度**（In-degree，指向该顶点的边的数量）和**出度**（Out-degree，从该顶点出发的边的数量）。
  * **路径 (Path)**: 从一个顶点到另一个顶点经过的边序列。
  * **环 (Cycle)**: 一条起点和终点相同的路径。

**解决的问题与应用**:
图是计算机科学中应用最广泛的模型之一，可以用来表示几乎任何关系网络：

  * **社交网络**: 用户是顶点，好友关系是边。
  * **交通网络**: 城市或交叉路口是顶点，公路、铁路或航线是边，边的权重可以代表距离或时间。
  * **互联网**: 网页是顶点，超链接是边。
  * **依赖关系**: 课程是顶点，先修关系是有向边（任务调度、软件依赖）。
  * **状态机**: 系统的每种状态是一个顶点，状态之间的转移是边。

## 算法模板

在编程中，主要有两种方法来表示图：**邻接矩阵**和**邻接表**。选择哪种表示方式取决于图的性质（稠密或稀疏）以及需要执行的操作类型。

### 模板一：邻接矩阵 (Adjacency Matrix)

邻接矩阵是一个 $V \times V$ 的二维数组（其中 $V$ 是顶点数），`matrix[i][j]` 存储了关于边 `(i, j)` 的信息。

![](C:\Users\24940\Desktop\C++笔记\数据结构\images\图的定义与表示\邻接矩阵-无向图.png)

![](C:\Users\24940\Desktop\C++笔记\数据结构\images\图的定义与表示\邻接矩阵-有向图.png)

**优缺点**:

  * **优点**: 实现简单；检查两个顶点之间是否存在边非常快（ $O(1)$）。
  * **缺点**: 空间复杂度高（ $O(V^2)$），即使图很稀疏（边很少）也要占用巨大空间；遍历一个顶点的所有邻居需要 $O(V)$ 时间。
  * **适用场景**: **稠密图**（边数 $E$ 接近 $V^2$），或需要频繁查询任意两点间是否存在边的场景。

**复杂度**:

  * 空间复杂度: $O(V^2)$
  * 添加边: $O(1)$
  * 检查边 `(u, v)`: $O(1)$
  * 遍历顶点 `u` 的所有邻居: $O(V)$

<!-- end list -->

```cpp
#include <vector>

const int MAX_VERTICES = 100; // 预设的最大顶点数

/**
 * @brief 邻接矩阵表示法
 */

// 假设顶点编号从 0 到 n-1

// --- 无权图 ---
// matrix[i][j] = 1 表示存在边 (i, j)，否则为 0
int unweighted_graph[MAX_VERTICES][MAX_VERTICES];

void add_unweighted_edge(int u, int v, bool is_directed) {
    unweighted_graph[u][v] = 1;
    if (!is_directed) {
        unweighted_graph[v][u] = 1;
    }
}

// --- 带权图 ---
const int INF = 1e9; // 代表无穷大，表示两点不直接相连
// matrix[i][j] = weight 表示边 (i, j) 的权重
int weighted_graph[MAX_VERTICES][MAX_VERTICES];
// 初始化: for i=0..n-1, for j=0..n-1, graph[i][j] = (i==j ? 0 : INF);

void add_weighted_edge(int u, int v, int weight, bool is_directed) {
    weighted_graph[u][v] = weight;
    if (!is_directed) {
        weighted_graph[v][u] = weight;
    }
}

```

### 模板二：邻接表 (Adjacency List)

邻接表是一个大小为 $V$ 的数组，数组的每个元素 `adj[i]` 是一个链表或动态数组，存储了所有与顶点 `i` 相邻的顶点。

![](C:\Users\24940\Desktop\C++笔记\数据结构\images\图的定义与表示\邻接表-无向图.png)

![](C:\Users\24940\Desktop\C++笔记\数据结构\images\图的定义与表示\邻接表-有向图.png)

**优缺点**:

  * **优点**: 空间复杂度低（ $O(V+E)$），非常节省空间；遍历一个顶点的所有邻居很高效。
  * **缺点**: 检查两个顶点 `u, v` 之间是否存在边需要 $O(\text{degree}(u))$ 的时间。
  * **适用场景**: **稀疏图**（边数 $E$ 远小于 $V^2$）。这是算法竞赛和大多数实际应用中最常用的表示方法。

**复杂度**:

  * 空间复杂度: $O(V+E)$
  * 添加边: $O(1)$ （摊销）
  * 检查边 `(u, v)`: $O(\text{degree}(u))$
  * 遍历顶点 `u` 的所有邻居: $O(\text{degree}(u))$

<!-- end list -->

```cpp
#include <vector>
#include <utility>

/**
 * @brief 邻接表表示法
 */

// 假设顶点编号从 0 到 n-1
int n; // 顶点数量

// --- 无权图 ---
// adj[i] 是一个 vector，存储所有与顶点 i 相邻的顶点
vector<vector<int>> unweighted_graph;

void init_unweighted(int num_vertices) {
    n = num_vertices;
    unweighted_graph.assign(n, vector<int>());
}

void add_unweighted_edge(int u, int v, bool is_directed) {
    unweighted_graph[u].push_back(v);
    if (!is_directed) {
        unweighted_graph[v].push_back(u);
    }
}

// --- 带权图 ---
// adj[i] 是一个 vector of pairs
// 每个 pair {v, w} 表示一条从 i 到 v 的边，权重为 w
vector<vector<pair<int, int>>> weighted_graph;

void init_weighted(int num_vertices) {
    n = num_vertices;
    weighted_graph.assign(n, vector<pair<int, int>>());
}

void add_weighted_edge(int u, int v, int weight, bool is_directed) {
    weighted_graph[u].push_back({v, weight});
    if (!is_directed) {
        weighted_graph[v].push_back({u, weight});
    }
}

```