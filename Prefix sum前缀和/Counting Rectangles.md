https://codeforces.com/contest/1722/problem/E

















































## 解题思路

1. 将所有矩形按其尺寸 (h×w) 映射到二维坐标系，在 **prefixsum2D [h] [w]**位置累加面积

2. 构建二维前缀和，使 prefixsum2D[i] [j] 表示所有"高度≤i 且 宽度≤j"的矩形面积总和

3. 将题目的开区间查询条件 (hs < hi < hb, ws < wi < wb) 转换为闭区间 [hs+1, hb-1] × [ws+1, wb-1]

4. 使用二维前缀和区间查询公式 O(1) 计算该区域的面积和

   ```
   可视化过程
   
   阶段1后（标记）：
   
        1   2   3   4   5
      +---+---+---+---+---+
   1  | 0 | 0 | 0 | 0 | 0 |
      +---+---+---+---+---+
   2  | 0 | 0 | 12| 0 | 0 |  ← 有两个2×3矩形，面积和=12
      +---+---+---+---+---+
   3  | 0 | 6 | 0 | 0 | 0 |  ← 有一个3×2矩形，面积=6
      +---+---+---+---+---+
      
   阶段2后（前缀和）：
        1   2   3   4   5
      +---+---+---+---+---+
   1  | 0 | 0 | 0 | 0 | 0 |
      +---+---+---+---+---+
   2  | 0 | 0 | 12| 12| 12|  ← 高≤2,宽≤3的和=12
      +---+---+---+---+---+
   3  | 0 | 6 | 18| 18| 18|  ← 高≤3,宽≤3的和=18 (包含所有矩形)
      +---+---+---+---+---+
   ```

   

## 代码实现

```cpp
#include <iostream>
#include <vector>
using namespace std;
using ll = long long;  // 使用 long long 避免溢出

int main() {
    // 加速输入输出
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t;
    cin >> t;  // 读入测试用例数量
    
    while (t--) {
        int n, q;
        cin >> n >> q;  // n: 矩形数量, q: 查询数量
        
        // ============ 步骤1: 初始化二维前缀和数组 ============
        // prefixsum[i][j] 最终将存储：所有高度 ≤ i 且宽度 ≤ j 的矩形的面积总和
        // 数组大小为 1001，因为高度和宽度范围是 [1, 1000]
        // 下标 0 作为边界，初始化为 0
        vector<vector<ll>> prefixsum(1001, vector<ll>(1001, 0));
        
        // ============ 步骤2: 读入矩形数据并累加面积 ============
        for (int i = 0; i < n; i++) {
            int h, w;
            cin >> h >> w;  // 读入第 i 个矩形的高度 h 和宽度 w
            
            // 将该矩形的面积 h*w 累加到 prefixsum[h][w] 位置
            // 注意：如果有多个相同尺寸的矩形，它们的面积会累加在同一个位置
            // 例如：有两个 2×3 的矩形，则 prefixsum[2][3] = 6 + 6 = 12
            prefixsum[h][w] += (ll)h * w;
        }
        
        // ============ 步骤3: 构建二维前缀和 ============
        // 目标：让 prefixsum[i][j] 表示从 (1,1) 到 (i,j) 矩形区域内所有矩形的面积总和
        for (int i = 1; i <= 1000; i++) {
            for (int j = 1; j <= 1000; j++) {
                // 二维前缀和公式：
                // prefixsum[i][j] = 当前位置的值
                //                 + 上方矩形的和 prefixsum[i-1][j]
                //                 + 左方矩形的和 prefixsum[i][j-1]
                //                 - 重复计算的左上角 prefixsum[i-1][j-1]
                
                prefixsum[i][j] += prefixsum[i-1][j]      // 加上上方的和
                                 + prefixsum[i][j-1]      // 加上左方的和
                                 - prefixsum[i-1][j-1];   // 减去重复计算的部分
                
                // 执行后，prefixsum[i][j] 就表示所有满足 (高度≤i 且 宽度≤j) 的矩形面积总和
            }
        }
        
        // ============ 步骤4: 处理查询 ============
        while (q--) {
            int hs, ws, hb, wb;
            cin >> hs >> ws >> hb >> wb;
            // 查询条件：找所有满足 hs < hi < hb 且 ws < wi < wb 的矩形面积和
            
            // ---------- 4.1: 转换查询范围 ----------
            // 原条件：hs < hi < hb 且 ws < wi < wb（开区间）
            // 转换为：hs+1 ≤ hi ≤ hb-1 且 ws+1 ≤ wi ≤ wb-1（闭区间）
            
            int r2 = hb - 1;  // 查询矩形的右下角行坐标（高度上界）
            int c2 = wb - 1;  // 查询矩形的右下角列坐标（宽度上界）
            int r1 = hs + 1;  // 查询矩形的左上角行坐标（高度下界）
            int c1 = ws + 1;  // 查询矩形的左上角列坐标（宽度下界）
            
            // 例如：查询 hs=1, ws=1, hb=3, wb=4
            // 需要找 1 < hi < 3 且 1 < wi < 4
            // 即 hi=2 且 wi ∈ {2,3}
            // 转换为查询区域 [2,2] 到 [2,3]
            
            ll res = 0;  // 初始化结果
            
            // ---------- 4.2: 检查查询区域是否合法 ----------
            // 如果 r1 > r2 或 c1 > c2，说明没有符合条件的矩形
            // 例如：hs=5, hb=6，则 r1=6, r2=5，区域不存在
            if (r1 <= r2 && c1 <= c2) {
                // ---------- 4.3: 使用二维前缀和公式计算区域和 ----------
                // 查询从 (r1, c1) 到 (r2, c2) 的矩形区域和
                // 公式：区域和 = 大矩形 - 上方矩形 - 左方矩形 + 左上角矩形
                
                res = prefixsum[r2][c2]              // 从 (1,1) 到 (r2,c2) 的总和
                    - prefixsum[r1-1][c2]            // 减去上方多余部分：(1,1) 到 (r1-1,c2)
                    - prefixsum[r2][c1-1]            // 减去左方多余部分：(1,1) 到 (r2,c1-1)
                    + prefixsum[r1-1][c1-1];         // 加回重复减去的左上角：(1,1) 到 (r1-1,c1-1)
                
                // 图示：
                // +-------------------+
                // |  A  |      B      |  A = prefixsum[r1-1][c1-1] (左上角)
                // |-----|-------------|  B = prefixsum[r1-1][c2] - A (上方)
                // |  C  | 查询区域 D  |  C = prefixsum[r2][c1-1] - A (左方)
                // +-------------------+  D = 我们要求的区域
                //
                // prefixsum[r2][c2] = A + B + C + D
                // D = prefixsum[r2][c2] - (A+B) - (A+C) + A
                //   = prefixsum[r2][c2] - B-A - C-A + A
                //   = prefixsum[r2][c2] - prefixsum[r1-1][c2] - prefixsum[r2][c1-1] + prefixsum[r1-1][c1-1]
            }
            
            // ---------- 4.4: 输出结果 ----------
            cout << res << '\n';
        }
    }
    
    return 0;
}
```

