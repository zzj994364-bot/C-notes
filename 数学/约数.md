# 约数 (Divisors)

## 基础

约数（Divisor），又称因数（Factor），是数论中的一个基本概念。如果一个整数 `N` 能被另一个整数 `d` 整除（即余数为0），那么 `d` 就是 `N` 的一个约数。对一个数 `N` 的约数进行分析是解决许多数论问题的基础。



核心概念：

  * **质因数分解**: 任何一个大于1的正整数都可以唯一地分解成一系列质数的乘积，形式为 $N = p_1^{a_1} p_2^{a_2} \cdots p_k^{a_k}$，其中 $p_i$ 是质数，$a_i$ 是其对应的指数。

    

常见应用：

  * **寻找一个数的所有约数**: 枚举出给定整数 `N` 的所有正约数。

  * **质因数分解**: 将一个数 `N` 分解为其质因数的乘积形式。这是后续操作的基础。

  * **计算约数个数**: 利用质因数分解的结果，可以快速计算出 `N` 的正约数个数。公式为 $\tau(N) = (a_1+1)(a_2+1)\cdots(a_k+1)$。

  * **计算约数之和**: 利用质因数分解的结果，计算 `N` 的所有正约数之和。公式为 $\sigma(N) = (1+p_1+\dots+p_1^{a_1})\cdots(1+p_k+\dots+p_k^{a_k})$。

  * **求最大公约数 (GCD) 和最小公倍数 (LCM)**: 约数和质因数分解是理解和计算 GCD/LCM 的理论基础。

    

时间/空间复杂度：

  * **试除法 (Trial Division)**: 以下模板都基于试除法，其核心思想是迭代到 $\sqrt{N}$。
  * **时间复杂度**: $O(\sqrt{N})$。
  * **空间复杂度**: $O(\log N)$（用于存储质因数）或 $O(d(N))$（用于存储所有约数， $d(N)$ 是约数个数）。

## 算法的流程

### 寻找所有约数的流程

1.  从 `i = 1` 迭代到 $\sqrt{N}$。
2.  在每次迭代中，检查 `N % i` 是否为 0。
3.  如果为 0，说明 `i` 是 `N` 的一个约数，将其存入结果列表。同时，`N / i` 也是 `N` 的一个约数，也将其存入。
4.  需要特别处理当 `i * i == N` 的情况，此时 `i` 和 `N / i` 是同一个数，只存入一次以避免重复。

### 质因数分解的流程

1.  从 `i = 2` 迭代到 $\sqrt{N}$。
2.  如果 `i` 是 `N` 的约数（`N % i == 0`），则 `i` 是一个质因数。
3.  进入一个循环，不断地让 `N` 除以 `i`，并统计 `i` 的个数，直到 `N` 不能再被 `i` 整除。
4.  外层循环继续，`i` 增加，寻找下一个质因数。
5.  当循环结束后，如果 `N` 仍然大于 1，说明剩下的 `N` 本身也是一个质因数。

## 算法模板

### 模板一：寻找所有约数

```cpp
#include <vector>
#include <numeric>
#include <algorithm>
#include <cmath>

/**
 * @brief 使用试除法寻找整数 n 的所有正约数
 * @param n 一个正整数
 * @return 包含 n 所有正约数的 vector，结果未排序
 */
vector<long long> get_divisors(long long n) {
    vector<long long> divisors;
    for (long long i = 1; i * i <= n; ++i) {
        if (n % i == 0) {
            divisors.push_back(i);
            // 避免 i*i=n 时重复添加
            if (i * i != n) {
                divisors.push_back(n / i);
            }
        }
    }
    // 如果需要有序结果，可以取消下面的注释
    // sort(divisors.begin(), divisors.end());
    return divisors;
}
```

### 模板二：质因数分解

```cpp
#include <vector>
#include <utility>

/**
 * @brief 对整数 n 进行质因数分解
 * @param n 一个正整数
 * @return 一个 vector of pairs，每个 pair 存储 {质因数, 指数}
 */
vector<pair<long long, int>> prime_factorize(long long n) {
    vector<pair<long long, int>> factors;
    for (long long i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            int count = 0;
            while (n % i == 0) {
                n /= i;
                count++;
            }
            factors.push_back({i, count});
        }
    }
    // 如果循环结束后 n 仍然大于 1，说明 n 本身是一个质因数
    if (n > 1) {
        factors.push_back({n, 1});
    }
    return factors;
}
```

### 模板三：计算约数个数

```cpp
#include <vector>
#include <utility>

/**
 * @brief 利用质因数分解计算 n 的正约数个数
 * @param n 一个正整数
 * @return n 的正约数个数
 */
long long count_divisors(long long n) {
    vector<pair<long long, int>> factors = prime_factorize(n);
    long long count = 1;
    for (const auto& p : factors) {
        // 应用公式 tau(N) = (a1+1)(a2+1)...
        count *= (p.second + 1);
    }
    return count;
}
```

### 模板四：计算约数之和

```cpp
#include <vector>
#include <utility>
#include <cmath>

/**
 * @brief 计算 p^0 + p^1 + ... + p^a (等比数列求和)
 * @param p 底数
 * @param a 最高指数
 * @return 等比数列的和
 */
long long power_sum(long long p, int a) {
    long long sum = 0;
    long long term = 1;
    for (int i = 0; i <= a; ++i) {
        sum += term;
        term *= p;
    }
    return sum;
}

/**
 * @brief 利用质因数分解计算 n 的所有正约数之和
 * @param n 一个正整数
 * @return n 的所有正约数之和
 */
long long sum_of_divisors(long long n) {
    if (n == 0) return 0;
    vector<pair<long long, int>> factors = prime_factorize(n);
    long long total_sum = 1;
    for (const auto& p : factors) {
        // 应用公式 sigma(N) = (1+p1+...+p1^a1)...
        total_sum *= power_sum(p.first, p.second);
    }
    return total_sum;
}
```