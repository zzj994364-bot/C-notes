# 差分数组 (Difference Array)

## 基础

差分数组是一种用于高效处理**区间修改**操作的数据结构或技巧。对于一个原数组 `a`，其差分数组 `d` 的定义为 `d[0] = a[0]` 且 `d[i] = a[i] - a[i-1]` (当 i \> 0)。

其核心思想在于**：对原数组 `a` 中一个区间 `[l, r]` 的所有元素加上一个值 `x`，这个操作等价于在差分数组 `d` 上进行两个单点修改：`d[l] += x` 和 `d[r+1] -= x`。**这使得区间操作的复杂度从 $O(N)$ 降到了 $O(1)$。

常见应用：适用于需要对数组进行大量区间加减操作，而对数组的查询次数较少的场景。例如：公交车上下车问题、航班预订统计、会议室预订等。

时间复杂度：

  * 构建差分数组: $O(N)$
  * 区间更新: $O(1)$
  * 从差分数组还原原数组: $O(N)$

空间复杂度： $O(N)$，用于存储差分数组。

**示例：**

```cpp
楼层高度：    [0, 3, 3, 5, 5, 5, 2]
高度变化：    [0, +3, 0, +2, 0, 0, -3]  ← 差分数组
             ↑   ↑   ↑   ↑
           起点 上3层 不变 上2层        下3层
```

## 算法的流程

1.  **构建差分数组 (Build):**

      * 根据原数组 `a` 构建出差分数组 `d`。
      * `d` 的长度通常比 `a` 大 1，以方便处理 `r+1` 的边界情况。
      * 计算 `d[0] = a[0]`，然后 `d[i] = a[i] - a[i-1]` for `i` from 1 to `n-1`。

2.  **执行区间更新 (Update):**

      * 对于每一个将区间 `[l, r]` 的元素值增加 `val` 的操作，只需更新差分数组的两个位置。
      * 执行 `d[l] += val`。
      * 如果 `r+1` 没有越界，则执行 `d[r+1] -= val`。

3.  **还原结果数组 (Reconstruct):**

      * 在所有更新操作执行完毕后，如果需要得到最终的原数组，可以通过对差分数组 `d` 求**前缀和**来还原。
      * `a[0] = d[0]`
      * `a[i] = a[i-1] + d[i]` for `i` from 1 to `n-1`。

## 算法模板

差分数组的思想非常适合封装成一个类，来管理其构建、更新和结果生成的过程。

  - **区间加法**: 对数组 `nums` 的一个子区间 `[l, r]` 的所有元素都加上 `val`。
  - **航班预订统计**: `bookings[i] = [first, last, seats]` 表示从 `first` 到 `last` 航班预订了 `seats` 个座位，计算每个航班的总预订数。
  - **拼车**: `trips[i] = [num, from, to]` 表示一次载客，计算车上在每个位置的乘客数是否超载。

(以封装类的形式为例)

```cpp
#include <iostream>
#include <vector>
#include <numeric>

/**
 * @brief 差分数组工具类
 */
class Difference {
private:
    // 差分数组
    vector<int> diff;

public:
    /**
     * @brief 构造函数，根据初始数组构建差分数组
     * @param nums 初始数组
     */
    Difference(const vector<int>& nums) {
        if (nums.empty()) {
            return;
        }
        // 1. 构建差分数组
        // diff 数组的长度可以和 nums 长度相同，在 increment 中处理边界
        // 或者长度为 n+1，更方便处理 r+1
        diff.resize(nums.size());
        diff[0] = nums[0];
        for (int i = 1; i < nums.size(); ++i) {
            diff[i] = nums[i] - nums[i-1];
        }
    }

    /**
     * @brief 对原数组的区间 [l, r] 增加 val
     * @param l 区间左边界 (包含)
     * @param r 区间右边界 (包含)
     * @param val 增加的值
     */
    void increment(int l, int r, int val) {
        // 2. 执行区间更新 (O(1) 复杂度)
        if (l < diff.size()) {
            diff[l] += val;
        }
        if (r + 1 < diff.size()) {
            diff[r + 1] -= val;
        }
    }

    /**
     * @brief 从差分数组还原结果数组
     * @return 返回经过所有区间更新操作后的最终数组
     */
    vector<int> result() const {
        if (diff.empty()) {
            return {};
        }
        // 3. 还原结果数组 (求前缀和)
        vector<int> res(diff.size());
        res[0] = diff[0];
        for (int i = 1; i < diff.size(); ++i) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }
};
```
