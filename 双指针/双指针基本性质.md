# 双指针 (Two Pointers) 技巧





## 什么是双指针？

**双指针 (Two Pointers)** 并不是 C++ 或任何语言的特定语法，而是一种在算法设计中极其常用且高效的**思维技巧**。

- 顾名思义，就是同时使用两个指针，在序列、链表结构上指向的是位置，在树、图结构中指向的是节点，通过**或同向移动，或相向移动**来维护、统计信息。

  常见应用：快慢指针、对撞指针、滑动窗口

  时间复杂度：O(n)，空间复杂度：O(1)



## 算法的流程
1.  **初始化：** 根据问题类型，初始化两个指针。
    * **快慢指针：** 通常 `slow` 和 `fast` 都指向序列的起始位置。
    * **左右指针：** `left` 指向序列的起始位置（索引 `0`），`right` 指向序列的结束位置（索引 `n-1`）。
    * **滑动窗口：** `left` 和 `right` 都指向序列的起始位置（索引 `0`）。
2.  **循环条件：** 设计一个循环，控制指针的移动。循环的终止条件是两个指针相遇、交错或其中一个指针到达序列的末端。

    * **快慢指针：** `while (fast != nullptr && fast->next != nullptr)` (链表)。
    * **左右指针：** `while (left < right)`。
    * **滑动窗口：** `while (right < n)`或`for (int right = 0; right < n; ++right)`通常由 `right` 指针控制主循环。
3.  **核心逻辑与指针移动：** 在循环体内，根据当前指针指向的元素值和问题要求，执行相应逻辑，并决定如何移动一个或两个指针。

    * **左右指针：** 比较 `arr[left]` 和 `arr[right]` 的和与 `target` 的关系，然后移动 `left` 或 `right`。
    * **滑动窗口：** `right` 指针通常每次循环都向右移动，以扩大窗口。当窗口满足（或不满足）某个条件时，在内层循环或 `if` 语句中移动 `left` 指针来收缩窗口。
4.  **终止与返回：** 循环结束后，返回结果。结果可能是在循环过程中找到的，也可能是在循环结束后根据指针的最终状态确定的。

------



### 模式一：对撞指针 (Collision Pointers)



也称为“相向指针”。这是最经典的一种模式，通常用于**已经排序**的序列。

- **工作方式**：一个指针 `left` (或 `i`) 从序列的**开头**开始，另一个指针 `right` (或 `j`) 从序列的**末尾**开始。
- **移动方式**：两个指针**相向移动**（`left` 向右, `right` 向左），直到它们相遇（`left >= right`）。
- **适用场景**：
  - 在*已排序*数组中查找“两数之和”。
  - 判断是否为“回文串”。
  - 反转数组或字符串。



#### 示例：两数之和 II (LeetCode 167 - 已排序数组)



**问题**：给定一个已升序排序的数组 `numbers` 和一个目标值 `target`，找出数组中两个数，使其和等于 `target`。返回这两个数的索引（从 1 开始）。

**C++ 代码实现**：

C++

```cpp
#include <vector>
#include <iostream>

// 假设数组已排序
std::vector<int> twoSumSorted(std::vector<int>& numbers, int target) {
    // 1. 初始化对撞指针
    int left = 0;
    int right = numbers.size() - 1;

    // 2. 循环直到两个指针相遇
    while (left < right) {
        int sum = numbers[left] + numbers[right];

        if (sum == target) {
            // 找到了！
            return {left + 1, right + 1}; // 按题目要求返回
        } 
        else if (sum < target) {
            // 当前和太小了，需要一个更大的数，让 left 向右移动
            left++;
        } 
        else { // sum > target
            // 当前和太大了，需要一个更小的数，让 right 向左移动
            right--;
        }
    }
    // 没有找到
    return {}; 
}

/*
int main() {
    std::vector<int> nums = {2, 7, 11, 15};
    int target = 9;
    std::vector<int> result = twoSumSorted(nums, target);
    // result 将是 {1, 2}
}
*/
```

------



### 模式二：快慢指针 (Fast & Slow Pointers)



两个指针从同一方向开始，但移动速度不同。
- **判断链表是否有环 (Floyd's Tortoise and Hare algorithm)**: 慢指针每次移动一步，快指针每次移动两步。如果相遇，则存在环。
- **寻找链表的中间节点**: 慢指针每次移动一步，快指针每次移动两步。当快指针到达终点时，慢指针正好在中间。
- **寻找链表的倒数第 k 个节点**: 让快指针先走 k 步，然后快慢指针同步前进，当快指针到达终点时，慢指针指向的就是倒数第 k 个节点。
- **在有序数组中原地移除重复项**: 慢指针指向下一个待填充的唯一元素位置，快指针遍历数组寻找不重复的元素。

 (以原地移除有序数组重复项为例)

```cpp
/**
 * @brief 快慢指针/同向双指针模板 (适用于需要原地修改的数组问题)
 * @param nums 待处理的有序数组
 * @return 返回处理后数组的新长度
 */
int fastSlowPointersTemplate(std::vector<int>& nums) {
    if (nums.empty()) {
        return 0;
    }

    // 1. 初始化：slow 指向新数组的末尾，fast 负责遍历原数组
    int slow = 0; 
    // fast 从 1 开始，因为 nums[0] 默认是第一个唯一元素
    for (int fast = 1; fast < nums.size(); ++fast) {
        // 2. 循环条件：fast 指针遍历整个数组

        // 3. 核心逻辑与指针移动
        // 当 fast 指向的元素与 slow 指向的元素不同时
        // 说明遇到了一个新的、不重复的元素
        if (nums[fast] != nums[slow]) {
            // slow 指针前进一步
            slow++;
            // 将 fast 指向的新元素复制到 slow 的位置
            nums[slow] = nums[fast];
        }
        // 如果 nums[fast] == nums[slow]，则 fast 继续前进，slow 保持不动
    }

    // 4. 返回结果：slow 的索引是 0-based，所以新数组的长度是 slow + 1
    return slow + 1;
}
```

------



### 模式三：滑动窗口 (Sliding Window)



两个指针 left 和 right 都从左向右移动，共同维护一个“窗口”。right 负责扩大窗口，left 负责收缩窗口。

- **寻找满足条件的最小/最大长度子数组/子串**: 例如，找到和大于等于 k 的最小连续子数组。right 向右移动扩大窗口，当窗口内的和满足条件时，记录长度，然后移动 left 缩小窗口，直到不再满足条件。
- **无重复字符的最长子串**: right 向右移动，用哈希表记录窗口内字符。当遇到重复字符时，移动 left，直到窗口内不再有这个重复字符。
- **字符串匹配/包含问题**: 例如，寻找字符串 s 中包含字符串 t 所有字符的最小子串。

#### 示例：长度最小的子数组 (LeetCode 209)



**问题**：给定一个含有 `n` 个正整数的数组 `nums` 和一个正整数 `target`。找出该数组中满足其和 $\ge$ `target` 的**长度最小**的**连续子数组**。

**C++ 代码实现**：

C++

```cpp
#include <vector>
#include <algorithm> // for std::min
#include <climits>   // for INT_MAX

int minSubArrayLen(int target, std::vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;

    // 1. 初始化指针和窗口变量
    int minLength = INT_MAX; // 存储最小长度
    int currentSum = 0;      // 窗口内元素的当前和
    int left = 0;            // 窗口的左边界

    // 2. 右指针 'right' 负责扩张窗口
    for (int right = 0; right < n; ++right) {
        currentSum += nums[right];

        // 3. 当窗口满足条件 (currentSum >= target) 时，
        //    尝试收缩左指针 'left'，并更新最小长度
        while (currentSum >= target) {
            // 更新最小长度
            minLength = std::min(minLength, (right - left) + 1);

            // 收缩窗口：从和中减去最左边的元素
            currentSum -= nums[left];
            // 左指针右移
            left++;
        }
    }

    // 4. 返回结果
    // 如果 minLength 没有被更新过（即没找到），返回 0
    return (minLength == INT_MAX) ? 0 : minLength;
}
```

#### 为什么不需要担心 `left > right`？

因为窗口**永远通过公式保证正确长度**：

```
max_length = max(max_length, right - left + 1);
```

当 `left = right + 1` 时：

```
right - left + 1 = right - (right+1) + 1 = 0
```

即窗口长度变为 `0`，意味着此时没有合法区间，这**完全符合逻辑**。

下一轮 `right++` 后窗口又会重新构建正常范围。



## 总结



双指针是一种思维模型，它本身并不复杂，但应用场景极其广泛。

- **对撞指针**：常用于**已排序**序列，利用序列的单调性从两端逼近答案。
- **快慢指针**：常用于**链表或环**检测，利用速度差来解决问题。
- **滑动窗口**：常用于**子数组/子串**问题，通过动态调整窗口大小来寻找最优解。

掌握双指针的关键在于识别出题目的“模式”，并确定两个指针的**初始位置、移动时机和循环的终止条件**。