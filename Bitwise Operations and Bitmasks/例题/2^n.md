https://codeforces.com/problemset/problem/913/A

## Modular Exponentiation

已知一个著名问题：

> 给定整数 $n$ 和 $m$，计算：
> $$
> m \bmod 2^n
> $$
> 其中 $2^n = 2\cdot 2\cdot \dots \cdot 2$（乘 n 次），$\bmod$ 表示取余。

现在要求**逆向问题**：

> 给定整数 $n$ 和 $m$，计算：
> $$
> ? \quad \text{使得} \quad m \bmod 2^n = ?
> $$

实际上，题目的意思就是**直接求 m 对 2^n 的余数**。

------

### **输入格式**

- 第一行：整数 $n$（1 ≤ n ≤ 10^8）
- 第二行：整数 $m$（1 ≤ m ≤ 10^8）

------

### **输出格式**

- 输出一个整数，即：

$$
m \bmod 2^n
$$

------

### **样例**

#### 样例 1

输入：

```
4
42
```

输出：

```
10
```

解释：
 2^4 = 16，42 % 16 = 10

------

#### 样例 2

输入：

```
1
58
```

输出：

```
0
```

解释：
 2^1 = 2，58 % 2 = 0

------

#### 样例 3

输入：

```
98765432
23456789
```

输出：

```
23456789
```

解释：
 2^98765432 是一个非常大的数，比 23456789 大，所以余数就是 23456789 本身。

















## 代码实现

```cpp
#include <iostream>
using namespace std;

int main () {
    long long n, m;
    cin >> n >> m;

    long long limit = 1LL << n; //使用 '<<' 来计算2^n
    if (n >= 64 || limit > m) cout << m << endl; //当n >= 64时会造成数据溢出(long long是64位) 
    else cout << m % limit << endl;
    
    return 0;
}
```

