# 二分查找
## 基础
二分查找（Binary Search）是一种在 **有序数组** 中查找特定元素的高效搜索算法。它的核心思想是利用数组的有序性，通过不断将搜索区间**缩小一半**来快速定位目标。

常见应用：精确查找、边界查找、答案范围二分等。

时间复杂度：**$O(log n)$**

## 算法的流程

以在升序数组`[left, right]`中查找特定元素为例，基本流程如下：

1. **初始化**
    * 定义两个指针，左指针 `left` 指向搜索区间的起始位置（通常是 `0`）。
    * 右指针 `right` 指向搜索区间的结束位置（通常是 `数组长度 - 1`）。
2. **循环搜索**
    * 当 `left <= right` 时，表示搜索区间仍然有效，继续循环。如果 `left > right`，则表示搜索区间为空，查找结束。
    * 计算中间位置的索引 `mid`。为了防止 `left + right` 溢出，推荐使用 `mid = left + (right - left) / 2`。
    * 将 `mid` 位置的元素值 `nums[mid]` 与目标值 `target`进行比较：
        * 如果 `nums[mid] == target`，表示已找到目标，可以直接返回 `mid`。
        * 如果 `nums[mid] < target`，表示目标值在 `mid` 的右侧，因此需要舍弃左半部分，将搜索区间更新为 `[mid + 1, right]`，即令 `left = mid + 1`。
        * 如果 `nums[mid] > target`，表示目标值在 `mid` 的左侧，因此需要舍弃右半部分，将搜索区间更新为 `[left, mid - 1]`，即令 `right = mid - 1`。
3. **结束**
    * 如果在循环中找到了 `target`，则返回其索引。
    * 如果循环结束仍未找到，表示数组中不存在该元素，通常返回 `-1` 或其他特殊值。

对于边界查找和答案范围上的二分，流程类似，但**区间的收缩逻辑 (`left` 和 `right` 的更新方式) 会根据具体问题有所不同**。

## 注意点
整数除法的特性，**mid靠向left**（方便手动处理的时候找到mid）

![](C:\Users\24940\Desktop\C++笔记\Binary search\images\mid靠向left.jpg)

## 寻找精确值（左闭右闭区间 [left, right]）
```cpp
/**
 * @brief 基础二分查找模板
 * @param nums  有序数组
 * @param target 目标值
 * @return 如果找到，返回目标值的索引；否则返回 -1
 */
int binarySearch(const std::vector<int>& nums, int target) {
    // 定义左闭右闭的搜索区间 [left, right]
    int left = 0;
    int right = nums.size() - 1;

    // 当 left <= right 时，区间 [left, right] 才有效
    while (left <= right) {
        // 防止 (left + right) 溢出
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            // 找到了目标值，直接返回索引
            return mid;
        } else if (nums[mid] < target) {
            // 目标值在右侧，搜索区间变为 [mid + 1, right]
            left = mid + 1;
        } else { // nums[mid] > target
            // 目标值在左侧，搜索区间变为 [left, mid - 1]
            right = mid - 1;
        }
    }

    // 未找到目标值
    return -1;
}
```
### 左闭右闭区间 [left, right]
未找到结束时，right在left左边(**left > right**)，**right处元素小于target，left处元素大于target**。

<img src="C:\Users\24940\Desktop\C++笔记\Binary search\images\[left,right]未找到1.jpg" style="zoom: 33%;" />

<img src="C:\Users\24940\Desktop\C++笔记\Binary search\images\[left,right]未找到2.jpg" style="zoom:33%;" />

## 寻找精确值左闭右开区间 [left, right)
```cpp
/**
 * @brief 基础二分查找模板（左闭右开区间）
 * @param nums  有序数组
 * @param target 目标值
 * @return 如果找到，返回目标值的索引；否则返回 -1
 */
int binarySearch(const std::vector<int>& nums, int target) {
    // 定义左闭右开的搜索区间 [left, right)
    int left = 0;             // 区间左边界，包含在搜索范围内
    int right = nums.size();  // 区间右边界，不包含在搜索范围内，指向最后一个元素的下一个位置

    // 当 left < right 时，区间 [left, right) 才有效（至少有一个元素）
    // 当 left == right 时，区间为 [left, left)，是空区间，循环终止
    while (left < right) {
        // 防止 (left + right) 溢出，计算方式不变
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            // 找到了目标值，直接返回索引
            return mid;
        } else if (nums[mid] < target) {
            // 目标值在右侧的子区间 [mid + 1, right) 中
            // 因为 nums[mid] 已经检查过且不是目标，所以新的搜索起点是 mid + 1
            left = mid + 1;
        } else { // nums[mid] > target
            // 目标值在左侧的子区间 [left, mid) 中
            // 因为 nums[mid] 已经检查过且不是目标，并且 right 是开区间，
            // 所以新的右边界可以直接设为 mid，将 mid 排除在新的搜索范围之外
            right = mid;
        }
    }

    // 循环结束时，left == right，表示区间已空，未找到目标值
    return -1;
}
```

### 左闭右开区间 [left, right)
left == right时，此处的元素值**大于或等于**target。相当于左闭右闭区间的 right + 1。

![](C:\Users\24940\Desktop\C++笔记\Binary search\images\123.jpg)


## 寻找边界lower_bound（左闭右开区间 [left, right)）
```cpp
/**
 * @brief 查找第一个大于等于 target 的元素（lower_bound）
 * @param nums  有序数组
 * @param target 目标值
 * @return 返回第一个大于等于 target 的元素的索引。如果所有元素都小于 target，则返回 nums.size()
 */
int lowerBound(const std::vector<int>& nums, int target) {
    // 定义左闭右开的搜索区间 [left, right)
    int left = 0;
    int right = nums.size(); // right 初始化为数组大小

    // 当 left < right 时，区间 [left, right) 才有效
    while (left < right) {
        // 防止溢出
        int mid = left + (right - left) / 2;

        if (nums[mid] >= target) { // 二分答案：这里为check函数
            // mid 位置的元素可能就是答案，或者答案在 mid 的左侧
            // 所以收缩右边界，搜索区间变为 [left, mid)
            right = mid;
        } else { // nums[mid] < target
            // mid 位置的元素肯定不是答案，答案在 mid 的右侧
            // 搜索区间变为 [mid + 1, right)
            left = mid + 1;
        }
    }
    
    // 循环结束时，left 和 right 相遇，指向的就是第一个大于等于 target 的位置
    return left;
}
```

## 寻找边界upper_bound（左闭右开区间 [left, right)）
```cpp
/**
 * @brief 查找第一个严格大于 target 的元素（upper_bound）
 * @param nums  有序数组
 * @param target 目标值
 * @return 返回第一个严格大于 target 的元素的索引。如果所有元素都小于等于 target，则返回 nums.size()
 */
int upperBound(const std::vector<int>& nums, int target) {
    // 定义左闭右开的搜索区间 [left, right)，这部分和 lower_bound 完全一样
    int left = 0;
    int right = nums.size(); // right 初始化为数组大小

    // 循环条件 left < right 保证了区间的有效性，也和 lower_bound 完全一样
    while (left < right) {
        // 防止溢出，计算中间点
        int mid = left + (right - left) / 2;

        // 这是与 lower_bound 唯一不同的核心逻辑判断
        if (nums[mid] <= target) {
            // 如果 mid 位置的元素小于等于 target，
            // 那么它肯定不是我们想要的答案（我们要找 > target 的）。
            // 并且，mid 左边的所有元素也都小于等于 target，也不是答案。
            // 因此，答案一定在 mid 的右侧，搜索区间变为 [mid + 1, right)
            left = mid + 1;
        } else { // nums[mid] > target
            // 如果 mid 位置的元素严格大于 target，
            // 那么它可能是我们想要的答案（第一个 > target 的元素）。
            // 或者，真正的答案还在 mid 的左侧。
            // 因此，我们不能排除 mid，需要继续在 [left, mid) 区间中搜索
            right = mid;
        }
    }
    
    // 循环结束时，left 和 right 相遇，指向的就是第一个严格大于 target 的位置
    // 这个返回值逻辑也和 lower_bound 完全一样
    return left;
}
```

## 二分答案
数字是天然有序的，所以答案可以应用二分，如整数区间[a, b]中找答案。
```cpp
// mid为答案，check函数验证答案正确性
bool check(int mid, int target) { 
    // func 计算同target含义的值，使得其与target可比较
    // 也可以没有 target 值，使得 func 满足某一个要求即可
    // 这里顺序尽量按 target < func(mid) , func(mid) < target，即用小于符号（可含等号）；这样能清晰的知道目标值在哪边
    return target <= func(mid);
}

// lower_bound
// 定义左闭右开的搜索区间 [left, right)
int lowerBound(int l, int r, int target) {
    int left = l;
    int right = r; 
    // 当 left < right 时，区间 [left, right) 才有效
    while (left < right) {
        // 防止溢出
        int mid = left + (right - left) / 2;
        if (check(mid, target)) { // 二分答案
            // mid 位置的元素可能就是答案，或者答案在 mid 的左侧
            // 所以收缩右边界，搜索区间变为 [left, mid)
            right = mid;
        } else { // func(mid) < target
            // mid 位置的元素肯定不是答案，答案在 mid 的右侧
            // 搜索区间变为 [mid + 1, right)
            left = mid + 1;
        }
    }    
    // 循环结束时，left 和 right 相遇，指向的就是第一个大于等于 target 的位置
    return left;
}

// upper_bound类似
```
