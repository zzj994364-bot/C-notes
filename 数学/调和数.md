# 调和数 (Harmonic Number)

## 基础

调和数（Harmonic Number/Series）是一个数学概念，在算法复杂度分析中非常重要，它本身不是一个“算法”。第 `n` 个调和数 $H_n$ 定义为前 `n` 个正整数倒数之和：
$H_n = 1 + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{n} = \sum_{k=1}^{n} \frac{1}{k}$

核心性质与近似：

  * 当 `n` 很大时，$H_n$ 的值可以被自然对数近似：
    $H_n \approx \ln(n) + \gamma$
  * 其中 $\gamma \approx 0.57721$ 是欧拉-马歇罗尼常数。在算法分析中，我们主要关心其增长趋势，即 $H_n$ 的数量级为 $O(\log n)$。

常见应用（主要用于复杂度分析）：

  * **分析特定循环结构的时间复杂度**: 这是调和级数在编程中最常见的应用场景。当一个算法包含形如“遍历所有数字 `i`，再遍历 `i` 的所有倍数”的嵌套循环时，其总操作次数就与调和级数相关。
  * **数论问题预计算**: 在许多数论问题中，需要预先计算出从 1 到 N 每个数的某些属性（如约数个数、约数之和）。实现这种预计算的算法，其复杂度常常是 $O(N \log N)$，这个结论就是通过调和级数得出的。
  * **筛法复杂度分析**: 经典的埃拉托斯特尼筛法（Sieve of Eratosthenes）的时间复杂度分析也与调和级数相关（更准确地说是素数倒数和），最终复杂度为 $O(N \log \log N)$。
  * **概率与期望**: 在一些概率问题中，例如著名的“赠券收集问题”（Coupon Collector's Problem），其期望收集次数的计算结果与调和级数直接相关。

## 算法的流程

调和级数本身没有算法流程，但它常用于分析以下这种特定算法模式的流程：

1.  **外层循环**: 从 `i = 1` 遍历到 `N`。
2.  **内层循环**: 对于每一个 `i`，内层循环遍历所有 `i` 在 `N` 以内的倍数 `j`（即 `j = i, 2*i, 3*i, ...` 直到 `j > N`）。
3.  **核心操作**: 在内层循环中对 `j` 执行某个 $O(1)$ 的操作。例如，统计 `j` 的约数个数时，`count[j]` 增加 1。
4.  **复杂度分析**:
      * 当 `i=1` 时，内层循环执行 `N/1` 次。
      * 当 `i=2` 时，内层循环执行 `N/2` 次。
      * ...
      * 当 `i=N` 时，内层循环执行 `N/N` 次。
      * 总执行次数为 $N/1 + N/2 + \dots + N/N = N \times (1 + 1/2 + \dots + 1/N) = N \times H_N$。
      * 由于 $H_N \approx O(\log N)$，所以该模式的总时间复杂度为 $O(N \log N)$。

## 算法模板

以下模板代码展示了这种具有 $O(N \log N)$ 复杂度的典型循环结构。

```cpp
#include <vector>

/**
 * @brief 演示调和级数复杂度的算法模板
 *
 * 该函数用于对 1 到 n 的每个数 j，执行一个与其所有约数 i 相关的操作。
 * 例如，可以用这个结构来预计算 1 到 n 每个数的约数个数。
 *
 * @param n 上限
 */
void harmonic_series_pattern(int n) {
    // 假设我们想计算 1 到 n 每个数的约数个数
    vector<int> divisor_count(n + 1, 0);

    // 外层循环：遍历所有可能的约数 i
    for (int i = 1; i <= n; ++i) {
        // 内层循环：遍历 i 的所有倍数 j (j <= n)
        // 对于每个这样的 j，i 都是它的一个约数。
        for (int j = i; j <= n; j += i) {
            // 执行 O(1) 操作。在这里，我们为 j 的约数个数加 1。
            divisor_count[j]++;
        }
    }
    
    // 经过这个双重循环后，divisor_count[j] 将存储 j 的约数个数。
    // 整个过程的总操作次数约为 N * log(N)，这就是调和级数的应用。
}
```