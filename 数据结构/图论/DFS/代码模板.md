# DFS题思考流程

- 如何**构造要求的图**（环？树？）

  - 邻接表是按**点**构造还是按**边**构造

    ```cpp
    vector<vector<int>> adj;
    //或者
    struct edge {
        int to;
        int weight;
    }
    vector<vector<edge>> adj;
    ```

- 题目的本质是求**图的什么属性**

- **DFS**遍历实现

  - 标记访问：将当前顶点 `u` 标记为已访问。
  - 处理当前节点
  - 继续传递
  - 探索邻居并调用递归
  - 返回: 当 `u` 的所有邻居都已被探索完毕，函数返回，程序回溯到调用 `dfs(u)` 的地方。





## 基础模板

```cpp
//adjacency list
vector<vector<int>> adj;
//visited
vector<bool> visited;

void dfs(int u) {
    //base case
    visited[u] = true;
    
    
    
    //遍历邻接点
    for (auto v : adj[u]) {
        //挑选子节点
        if (!visited[v]) { //“递”条件
            
            //写入recursive case
            
        }
    }
}
```



## 按边DFS

但一旦题目出现下面任何一个关键词，普通**按点 DFS** 就会**失效**：

- **“每条边都要处理”**
- **“回边 / 环 / 重边”**
- **“边有权值 / 方向 / 状态”**
- **“必须走完整个环”**

```cpp
struct directed_edge{
    int to;
    int cost;
};

//directed edge adj
vector<vector<directed_edge>> adj;
long long ans;

void dfs(int to, int from, int cost) {
    if (to == 1) {
        ans = cost;
        return;
    }
    for (auto e : adj[to]) {
        if (e.to != from) {
            dfs(e.to, to, cost + e.cost);
        }
    }
}

```





## 参数传递/回溯 and 判断叶子节点 and 结束当前分支

```cpp
//将continuous_cats传递下去
//如果设成全局变量就无法“回溯恢复”
void dfs(int u, int continuous_cats) {
    //base case
    visited[u] = true;

    if (cats[u] == 1) continuous_cats++;
    if (cats[u] == 0) continuous_cats = 0;
    if (continuous_cats > m) return; //结束当前分支
    
    bool isLeaf = true;
    //遍历邻接点
    for (auto v : graph[u]) {
        //挑选子节点
        if (!visited[v]) {
            isLeaf = false; //当他有子节点时他就不是叶子节点
            dfs(v, continuous_cats);
        }
    }

    if (isLeaf) ans++;
}
```



## 子树和

```cpp
vector<vector<int>> graph;
vector<bool> visited;
vector<int> all_subordinates;

//直接统计all_subordinates
int dfs(int u) {
    int total = 0;
    visited[u] = true;

    //遍历所有邻接点
    for (auto v : graph[u]) {
        //确保访问子节点
        if (!visited[v]) {
            int subtree_size = dfs(v);
            total += subtree_size;
        }
    }

    all_subordinates[u] = total;
    return total + 1;
}

//all_subordinates[u] = 下属数量
//dfs(u) 返回 = 子树大小（含自己）
```



## 子树最大深度

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct edge {
    int to;
    int cost;
};

vector<vector<edge>> adj;
vector<bool> visited;

// 返回从节点u出发，能达到的最大路径代价
int dfs(int u) {
    visited[u] = true;
    int max_depth = 0; // ← 每次调用都创建新的变量,每个节点的 max_depth 都是独立的。
    
    for (auto e : adj[u]) {
        if (!visited[e.to]) {
            int child_depth = dfs(e.to); // ← 递归调用
            max_depth = max(max_depth, e.cost + child_depth);
        }
    }
    
    return max_depth; // ← 返回当前层的max_depth
}

int main() {
    int n;
    cin >> n;
    
    adj.resize(n);
    visited.resize(n, false);
    
    for (int i = 0; i < n - 1; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        adj[a].push_back({b, c});
        adj[b].push_back({a, c});
    }
    
    int root = 0;
    visited[root] = true;
    
    int global_max = 0;
    
    // 对根的每个子树求最大深度
    for (auto e : adj[root]) {
        int subtree_max = e.cost + dfs(e.to);
        cout << "子树 " << e.to << " 最大路径: " << subtree_max << endl;
        global_max = max(global_max, subtree_max);
    }
    
    cout << "全局最大路径: " << global_max << endl;
    
    return 0;
}
```





## int类型模板

```cpp
vector<vector<int>> graph;
vector<bool> visited;
vector<int> all_subordinates;

//直接统计all_subordinates
int dfs(int u) {
    int total = 0;
    visited[u] = true;

    //遍历所有邻接点
    for (auto v : graph[u]) {
        //确保访问子节点
        if (!visited[v]) {
            int subtree_size = dfs(v);
            total += subtree_size;
        }
    }

    all_subordinates[u] = total;
    return total + 1;
}
```