# Coordinate Compression(坐标压缩)

比较**重要**的几个参数：

- **原始数据** 向 **下标** 的 mapping
  - 查找用，建图、DP、并查集
- **下标** 向 **原始数据** 的 mapping
  - 反向输出、区间还原、调试神器
- **原始数据** 的 size
  - 决定数组大小、复杂度、是否能开静态数组

## 一、什么是离散化

离散化是一种常用的算法技巧,用于处理数据范围很大但数据个数相对较少的问题。它的核心思想是将原本分散的、范围很大的数据映射到一个较小的连续区间内,从而降低空间复杂度和时间复杂度。

### 适用场景

- 数据范围很大(如 10^9),但数据个数较少(如 10^5)
- 需要使用数组下标访问数据
- 只关心数据之间的相对大小关系,不关心具体值

### 典型例子

假设有坐标: [1, 1000000000, 5, 10000] 离散化后: [1, 4, 2, 3]

通过离散化,我们将 10^9 范围的数据压缩到了 1~4 的范围内,同时保持了相对大小关系。

## 二、离散化的基本步骤

### 标准流程

1. collect:**收集所有需要离散化的值**
   - 将所有数据存入数组
2. sort:**排序**
   - 对数组进行排序
3. unique:**去重**
   - 删除重复元素
4. map:**映射**
   - 建立原值与离散化后值的对应关系

### 代码实现(C++)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> nums;  // 存储原始数据
vector<int> tmp;   // 用于离散化的临时数组

// 离散化函数
int get(int x) {
    // 使用二分查找找到x在排序去重后数组中的位置
    return lower_bound(tmp.begin(), tmp.end(), x) - tmp.begin() + 1;
}

int main() {
    // 1. 收集数据
    nums = {1000000000, 5, 10000, 1, 5};
    tmp = nums;
    
    // 2. 排序
    sort(tmp.begin(), tmp.end());
    
    // 3. 去重
    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());
    
    // 4. 映射使用
    for (int x : nums) {
        cout << x << " -> " << get(x) << endl;
    }
    
    return 0;
}
```

## 三、离散化的两种方式

### 方式一:保序离散化(常用)

保持元素的相对大小关系,将数据映射到 1, 2, 3, ...

**特点:**

- 映射后的值从 1(或 0)开始连续递增
- 相同的原值映射到相同的离散值
- 保持原数据的大小关系

**实现:**

```cpp
// 排序 + 去重 + 二分查找
sort(a.begin(), a.end());
a.erase(unique(a.begin(), a.end()), a.end());

int find(int x) {
    return lower_bound(a.begin(), a.end(), x) - a.begin() + 1;
}
```

### 方式二:哈希映射

使用 map 或 unordered_map 建立映射关系。

**实现:**

```cpp
map<int, int> mp;
int cnt = 0;

for (int x : nums) {
    if (mp.find(x) == mp.end()) {
        mp[x] = ++cnt;
    }
}
```

## 四、经典例题与应用

### 例题1: 区间和问题

**题目描述:** 给定 n 个区间操作,每个操作在位置 x 处加上 c。给定 m 个查询,每个查询求区间 [l, r] 的和。 数据范围: 1 ≤ x, l, r ≤ 10^9, n, m ≤ 10^5

**思路:** 由于坐标范围很大但操作数量少,直接开数组会 MLE。使用离散化将所有出现的坐标压缩。

**代码框架:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef pair<int, int> PII;

const int N = 300010;  // n + 2m 个坐标
int n, m;
int a[N], s[N];  // 离散化后的数组和前缀和

vector<int> alls;  // 存储所有待离散化的坐标
vector<PII> add, query;  // 存储操作和查询

// 二分查找离散化后的值
int find(int x) {
    int l = 0, r = alls.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l + 1;  // 映射到1, 2, 3, ...
}

int main() {
    cin >> n >> m;
    
    // 读取插入操作
    for (int i = 0; i < n; i++) {
        int x, c;
        cin >> x >> c;
        add.push_back({x, c});
        alls.push_back(x);
    }
    
    // 读取查询操作
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
    
    // 离散化
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());
    
    // 执行插入操作
    for (auto item : add) {
        int x = find(item.first);
        a[x] += item.second;
    }
    
    // 构建前缀和
    for (int i = 1; i <= alls.size(); i++) {
        s[i] = s[i - 1] + a[i];
    }
    
    // 处理查询
    for (auto item : query) {
        int l = find(item.first), r = find(item.second);
        cout << s[r] - s[l - 1] << endl;
    }
    
    return 0;
}
```

### 例题2: 线段覆盖问题

**题目描述:** 数轴上有 n 条线段,求被至少一条线段覆盖的点的个数。

**思路:**

1. 收集所有端点进行离散化
2. 使用差分数组或扫描线算法
3. 统计覆盖次数 > 0 的点

### 例题3: 二维离散化

**问题:** 在二维平面上有若干矩形操作,坐标范围 10^9,数量 10^5。

**方法:** 分别对 x 坐标和 y 坐标进行离散化。

```cpp
vector<int> xs, ys;  // 存储所有x和y坐标

// 收集坐标
for (auto rect : rectangles) {
    xs.push_back(rect.x1);
    xs.push_back(rect.x2);
    ys.push_back(rect.y1);
    ys.push_back(rect.y2);
}

// 分别离散化
sort(xs.begin(), xs.end());
xs.erase(unique(xs.begin(), xs.end()), xs.end());
sort(ys.begin(), ys.end());
ys.erase(unique(ys.begin(), ys.end()), ys.end());

// 使用
int new_x = lower_bound(xs.begin(), xs.end(), x) - xs.begin();
int new_y = lower_bound(ys.begin(), ys.end(), y) - ys.begin();
```

## 五、常见技巧与注意事项

### 技巧1: 边界处理

有些题目需要考虑区间端点和内部点,可能需要离散化时多加一些点:

- 对于区间 [l, r],可能需要同时离散化 l-1, l, r, r+1

### 技巧2: 使用 STL 函数

```cpp
// 排序
sort(a.begin(), a.end());

// 去重
a.erase(unique(a.begin(), a.end()), a.end());

// 二分查找(返回第一个 >= x 的位置)
lower_bound(a.begin(), a.end(), x);

// 二分查找(返回第一个 > x 的位置)
upper_bound(a.begin(), a.end(), x);
```

### 技巧3: 映射从 0 还是从 1 开始?

- 从 1 开始:方便使用前缀和(s[0] = 0)
- 从 0 开始:符合数组习惯,代码更简洁

根据具体题目选择,保持一致即可。

### 注意事项

1. **去重的重要性**
   - 不去重会导致二分查找结果不唯一
   - unique() 只能去除相邻重复元素,必须先排序
2. **数组大小**
   - 离散化后数组大小为离散化元素个数
   - 注意不同操作可能引入不同数量的坐标点
3. **精度问题**
   - 浮点数离散化需要特别注意精度
   - 可以先乘以倍数转换为整数
4. **时间复杂度**
   - 排序: O(n log n)
   - 去重: O(n)
   - 查询: O(log n) 每次

## 六、模板代码

### C++ 完整模板

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Discretization {
private:
    vector<int> nums;
    
public:
    // 添加需要离散化的数
    void add(int x) {
        nums.push_back(x);
    }
    
    // 初始化:排序去重
    void init() {
        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
    }
    
    // 查询x离散化后的值(从1开始)
    int get(int x) {
        return lower_bound(nums.begin(), nums.end(), x) - nums.begin() + 1;
    }
    
    // 获取离散化后的数组大小
    int size() {
        return nums.size();
    }
    
    // 获取第i个离散化的原值
    int getValue(int i) {
        return nums[i - 1];
    }
};

int main() {
    Discretization disc;
    
    // 使用示例
    disc.add(1000000);
    disc.add(5);
    disc.add(10);
    disc.add(5);  // 重复值
    
    disc.init();
    
    cout << "5 -> " << disc.get(5) << endl;
    cout << "10 -> " << disc.get(10) << endl;
    cout << "1000000 -> " << disc.get(1000000) << endl;
    
    return 0;
}
```

### Python 版本

```python
class Discretization:
    def __init__(self):
        self.nums = []
        self.sorted_nums = []
    
    def add(self, x):
        self.nums.append(x)
    
    def init(self):
        self.sorted_nums = sorted(set(self.nums))
    
    def get(self, x):
        # 二分查找
        import bisect
        return bisect.bisect_left(self.sorted_nums, x) + 1
    
    def size(self):
        return len(self.sorted_nums)

# 使用示例
disc = Discretization()
disc.add(1000000)
disc.add(5)
disc.add(10)
disc.init()

print(f"5 -> {disc.get(5)}")
print(f"10 -> {disc.get(10)}")
print(f"1000000 -> {disc.get(1000000)}")
```

## 七、总结

离散化是处理大范围稀疏数据的有效方法,核心在于:

1. **空间压缩**: 将大范围映射到小范围
2. **保序性**: 维持数据的相对大小关系
3. **快速查询**: 使用二分查找实现 O(log n) 查询

**适用场景总结:**

- 坐标压缩
- 区间操作问题
- 数据范围大但数据量小的问题
- 需要快速访问和查询的问题

掌握离散化技巧可以有效解决许多看似复杂的算法问题!