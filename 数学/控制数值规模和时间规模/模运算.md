# 模运算

## 目录
1. [基础概念](#1-基础概念)
2. [模运算的性质](#2-模运算的性质)
3. [模运算的四则运算](#3-模运算的四则运算)
4. [乘法逆元](#4-乘法逆元)
5. [费马小定理](#5-费马小定理)
6. [快速幂算法](#6-快速幂算法)
7. [扩展欧几里得算法](#7-扩展欧几里得算法)
8. [中国剩余定理](#8-中国剩余定理)
9. [实战应用](#9-实战应用)
10. [常见陷阱](#10-常见陷阱)

---

## 1. 基础概念

### 1.1 什么是模运算？

**定义**：对于整数 a 和正整数 n，a 除以 n 的余数称为 a 模 n，记作 `a mod n`。

**数学表示**：
```
a = q × n + r  （其中 0 ≤ r < n）
a mod n = r
```

**示例**：
```
17 mod 5 = 2    （因为 17 = 3×5 + 2）
-17 mod 5 = 3   （因为 -17 = -4×5 + 3）
100 mod 7 = 2   （因为 100 = 14×7 + 2）
```

### 1.2 同余的概念

**定义**：如果 a 和 b 除以 n 的余数相同，则称 a 和 b 模 n 同余，记作：
```
a ≡ b (mod n)
```

**等价表示**：
```
a ≡ b (mod n)  ⟺  n | (a - b)  ⟺  a mod n = b mod n
```

**示例**：
```
17 ≡ 2 (mod 5)    因为 17 mod 5 = 2, 2 mod 5 = 2
23 ≡ 3 (mod 10)   因为 23 mod 10 = 3, 3 mod 10 = 3
-1 ≡ 4 (mod 5)    因为 -1 mod 5 = 4, 4 mod 5 = 4
```

### 1.3 模运算的基本性质

1. **反身性**：`a ≡ a (mod n)`
2. **对称性**：若 `a ≡ b (mod n)`，则 `b ≡ a (mod n)`
3. **传递性**：若 `a ≡ b (mod n)` 且 `b ≡ c (mod n)`，则 `a ≡ c (mod n)`

---

## 2. 模运算的性质

### 2.1 核心性质

**性质1：加法**
```
(a + b) mod n = [(a mod n) + (b mod n)] mod n
```

**性质2：减法**
```
(a - b) mod n = [(a mod n) - (b mod n) + n] mod n
```
注意：加上 n 是为了保证结果非负

**性质3：乘法**
```
(a × b) mod n = [(a mod n) × (b mod n)] mod n
```

**性质4：幂运算**
```
a^k mod n = [(a mod n)^k] mod n
```

### 2.2 性质证明示例

**证明乘法性质**：

设 `a = q₁n + r₁`（其中 `r₁ = a mod n`）  
设 `b = q₂n + r₂`（其中 `r₂ = b mod n`）

则：
```
a × b = (q₁n + r₁)(q₂n + r₂)
      = q₁q₂n² + q₁nr₂ + q₂nr₁ + r₁r₂
      = n(q₁q₂n + q₁r₂ + q₂r₁) + r₁r₂
```

对两边取 mod n：
```
(a × b) mod n = r₁r₂ mod n
              = [(a mod n) × (b mod n)] mod n
```

### 2.3 重要推论

**推论1：可以随时取模**
```
在计算过程中的任何时候取模，都不会改变最终结果
例如：(a × b × c) mod n
可以写成：[((a mod n) × (b mod n)) mod n × (c mod n)] mod n
```

**推论2：分配律**
```
(a + b) × c ≡ (a × c + b × c) (mod n)
```

---

## 3. 模运算的四则运算

### 3.1 加法

**公式**：`(a + b) mod n`

**代码实现**：
```cpp
long long add_mod(long long a, long long b, long long n) {
    return ((a % n) + (b % n)) % n;
}
```

**示例**：
```
(23 + 17) mod 10 = 40 mod 10 = 0
或：[(23 mod 10) + (17 mod 10)] mod 10 = (3 + 7) mod 10 = 0 ✓
```

### 3.2 减法

**公式**：`(a - b) mod n`

**注意**：需要处理负数情况！

**代码实现**：
```cpp
long long sub_mod(long long a, long long b, long long n) {
    return ((a % n) - (b % n) + n) % n;
}
```

**为什么要 +n？**
```
例如：(3 - 7) mod 5
直接算：-4 mod 5 = 1（需要特殊处理负数）
加n后：(-4 + 5) mod 5 = 1 mod 5 = 1 ✓
```

### 3.3 乘法

**公式**：`(a × b) mod n`

**代码实现**：
```cpp
long long mul_mod(long long a, long long b, long long n) {
    return ((a % n) * (b % n)) % n;
}
```

**示例**：
```
(123 × 456) mod 100
= [(123 mod 100) × (456 mod 100)] mod 100
= (23 × 56) mod 100
= 1288 mod 100
= 88
```

### 3.4 除法（最复杂！）

**关键点**：模运算中没有直接的除法！

**问题**：求 `(a / b) mod n`

**解决方法**：转换为乘法
```
(a / b) mod n = (a × b⁻¹) mod n
```
其中 `b⁻¹` 是 b 的**乘法逆元**

---

## 4. 乘法逆元

### 4.1 定义

**乘法逆元**：对于整数 b 和模数 n，如果存在整数 x 使得：
```
b × x ≡ 1 (mod n)
```
则称 x 为 b 在模 n 下的乘法逆元，记作 `b⁻¹` 或 `inv(b)`。

### 4.2 存在性

**定理**：b 在模 n 下存在逆元 ⟺ gcd(b, n) = 1（b 和 n 互质）

**示例**：
```
✓ 3 在 mod 7 下有逆元（gcd(3,7)=1）
  3 × 5 = 15 ≡ 1 (mod 7)，所以 3⁻¹ = 5

✗ 4 在 mod 6 下没有逆元（gcd(4,6)=2≠1）
  4×1=4, 4×2=8≡2, 4×3=12≡0, 4×4=16≡4, 4×5=20≡2
  没有任何 x 使得 4x ≡ 1 (mod 6)
```

### 4.3 求逆元的方法

#### 方法1：暴力枚举（仅适用于小模数）

```cpp
int find_inverse_brute(int b, int n) {
    for (int x = 1; x < n; x++) {
        if ((b * x) % n == 1) {
            return x;
        }
    }
    return -1; // 不存在
}
```

**时间复杂度**：O(n)

#### 方法2：费马小定理（n 为质数）

当 n 是质数时：
```
b⁻¹ ≡ b^(n-2) (mod n)
```

```cpp
long long inverse_fermat(long long b, long long n) {
    return power_mod(b, n - 2, n);
}
```

**时间复杂度**：O(log n)

#### 方法3：扩展欧几里得算法（通用）

适用于任何 gcd(b, n) = 1 的情况。

```cpp
long long exgcd(long long a, long long b, long long &x, long long &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    long long d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

long long inverse_exgcd(long long b, long long n) {
    long long x, y;
    long long d = exgcd(b, n, x, y);
    if (d != 1) return -1; // 不存在逆元
    return (x % n + n) % n;
}
```

**时间复杂度**：O(log n)

### 4.4 逆元的性质

1. **唯一性**：如果逆元存在，则在 [0, n-1] 范围内唯一
2. **乘法性**：`(ab)⁻¹ ≡ a⁻¹ × b⁻¹ (mod n)`
3. **幂次性**：`(a⁻¹)^k ≡ (a^k)⁻¹ (mod n)`
4. **倒数性**：`(a⁻¹)⁻¹ ≡ a (mod n)`

---

## 5. 费马小定理

### 5.1 定理陈述

**费马小定理（Fermat's Little Theorem）**：

如果 p 是质数，a 是不被 p 整除的整数（即 gcd(a, p) = 1），那么：
```
a^(p-1) ≡ 1 (mod p)
```

**推论**：
```
a^p ≡ a (mod p)（对所有整数 a 成立）
```

### 5.2 应用：求逆元

从 `a^(p-1) ≡ 1 (mod p)` 可得：
```
a^(p-1) = a × a^(p-2) ≡ 1 (mod p)
```

因此：
```
a⁻¹ ≡ a^(p-2) (mod p)
```

### 5.3 证明思路

**证明**（简化版）：

考虑集合 `S = {1, 2, 3, ..., p-1}`

对于任意 `a`（gcd(a, p) = 1），考虑集合：
```
T = {a×1 mod p, a×2 mod p, ..., a×(p-1) mod p}
```

可以证明 T 是 S 的一个排列（双射），因此：
```
(a×1) × (a×2) × ... × (a×(p-1)) ≡ 1 × 2 × ... × (p-1) (mod p)
a^(p-1) × (p-1)! ≡ (p-1)! (mod p)
a^(p-1) ≡ 1 (mod p)
```

### 5.4 验证示例

**示例1**：a=2, p=7
```
2^(7-1) = 2^6 = 64
64 = 9×7 + 1
所以 2^6 ≡ 1 (mod 7) ✓
```

**示例2**：a=3, p=5
```
3^(5-1) = 3^4 = 81
81 = 16×5 + 1
所以 3^4 ≡ 1 (mod 5) ✓
```

### 5.5 局限性

⚠️ **费马小定理只适用于质数模数！**

反例（n=4 不是质数）：
```
3^(4-1) = 3^3 = 27
27 mod 4 = 3 ≠ 1
```

---

## 6. 快速幂算法

### 6.1 问题

计算 `a^b mod n`，其中 b 可能非常大（如 10^9）。

**朴素方法**：
```cpp
long long result = 1;
for (int i = 0; i < b; i++) {
    result = (result * a) % n;
}
```
**时间复杂度**：O(b) —— 太慢！

### 6.2 快速幂原理

**核心思想**：利用二进制分解

任何数都可以表示为 2 的幂次之和：
```
例如：13 = 8 + 4 + 1 = 2³ + 2² + 2⁰
所以：a^13 = a^8 × a^4 × a^1
```

**一般化**：
```
若 b = b_k × 2^k + b_(k-1) × 2^(k-1) + ... + b_1 × 2 + b_0
则 a^b = a^(b_k × 2^k) × a^(b_(k-1) × 2^(k-1)) × ... × a^(b_1 × 2) × a^(b_0)
```

### 6.3 算法实现

#### 递归版本

```cpp
long long power_mod_recursive(long long a, long long b, long long n) {
    if (b == 0) return 1;
    
    long long half = power_mod_recursive(a, b / 2, n);
    long long result = (half * half) % n;
    
    if (b % 2 == 1) {
        result = (result * a) % n;
    }
    
    return result;
}
```

#### 迭代版本（推荐）

```cpp
long long power_mod(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    
    while (exp > 0) {
        if (exp & 1) {  // 如果当前位是1
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp >>= 1;  // 右移一位
    }
    
    return result;
}
```

### 6.4 算法分析

**时间复杂度**：O(log b)

**空间复杂度**：
- 递归版：O(log b)（调用栈）
- 迭代版：O(1)

### 6.5 手动模拟

计算 `3^13 mod 7`：

```
13 的二进制：1101

初始：result = 1, base = 3

第1轮：exp=13 (1101₂), 最低位=1
  result = (1 × 3) mod 7 = 3
  base = (3 × 3) mod 7 = 9 mod 7 = 2
  exp = 6 (110₂)

第2轮：exp=6 (110₂), 最低位=0
  result = 3（不变）
  base = (2 × 2) mod 7 = 4
  exp = 3 (11₂)

第3轮：exp=3 (11₂), 最低位=1
  result = (3 × 4) mod 7 = 12 mod 7 = 5
  base = (4 × 4) mod 7 = 16 mod 7 = 2
  exp = 1 (1₂)

第4轮：exp=1 (1₂), 最低位=1
  result = (5 × 2) mod 7 = 10 mod 7 = 3
  base = (2 × 2) mod 7 = 4
  exp = 0

结束：result = 3
```

验证：`3^13 = 1594323 = 227760×7 + 3` ✓

---

## 7. 扩展欧几里得算法

### 7.1 欧几里得算法（GCD）

**目的**：求最大公约数 gcd(a, b)

**算法**：
```
gcd(a, b) = gcd(b, a mod b)
gcd(a, 0) = a
```

**代码**：
```cpp
long long gcd(long long a, long long b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

**示例**：
```
gcd(48, 18):
  gcd(48, 18) = gcd(18, 12) = gcd(12, 6) = gcd(6, 0) = 6
```

### 7.2 扩展欧几里得算法

**目的**：求解方程 `ax + by = gcd(a, b)`

**算法思想**：

1. 如果 `b = 0`，则 `gcd(a, 0) = a`，方程为 `ax + 0y = a`，解为 `x=1, y=0`

2. 否则，递归求解 `bx' + (a mod b)y' = gcd(b, a mod b)`

3. 由于 `a mod b = a - ⌊a/b⌋×b`，代入得：
   ```
   bx' + (a - ⌊a/b⌋×b)y' = gcd(a, b)
   ay' + b(x' - ⌊a/b⌋×y') = gcd(a, b)
   ```
   
4. 因此：`x = y'`, `y = x' - ⌊a/b⌋×y'`

**代码**：
```cpp
long long exgcd(long long a, long long b, long long &x, long long &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    long long d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
```

### 7.3 应用：求乘法逆元

要求 b 在模 n 下的逆元，即求 x 使得：
```
bx ≡ 1 (mod n)
⟺ bx + ny = 1（存在整数 y）
⟺ gcd(b, n) = 1
```

使用扩展欧几里得求解 `bx + ny = 1`，得到的 x 就是逆元。

**代码**：
```cpp
long long mod_inverse(long long b, long long n) {
    long long x, y;
    long long d = exgcd(b, n, x, y);
    if (d != 1) return -1; // 逆元不存在
    return (x % n + n) % n; // 保证结果为正
}
```

### 7.4 示例

求 `3⁻¹ mod 7`：

```
求解：3x + 7y = 1

exgcd(3, 7):
  exgcd(7, 3):
    exgcd(3, 1):
      exgcd(1, 0):
        return x=1, y=0, d=1
      回溯：y = 0 - 3/1×1 = -3, x=0, d=1
      所以 1×(-3) + 0×? = 1 （实际上是 1×1 + 0×? = 1）
    ...递归回溯...
  最终：x=5, y=-2

验证：3×5 + 7×(-2) = 15 - 14 = 1 ✓
所以 3⁻¹ ≡ 5 (mod 7)
```

---

## 8. 中国剩余定理

### 8.1 问题

**中国剩余定理（Chinese Remainder Theorem, CRT）**解决的问题：

给定一组同余方程：
```
x ≡ a₁ (mod n₁)
x ≡ a₂ (mod n₂)
...
x ≡ aₖ (mod nₖ)
```

其中 n₁, n₂, ..., nₖ **两两互质**，求 x。

### 8.2 定理

如果 n₁, n₂, ..., nₖ 两两互质，则方程组在模 `N = n₁×n₂×...×nₖ` 意义下有唯一解。

### 8.3 求解方法

设 `N = n₁ × n₂ × ... × nₖ`，`Nᵢ = N / nᵢ`

1. 对每个 i，求 `Mᵢ` 使得 `Nᵢ × Mᵢ ≡ 1 (mod nᵢ)`（即 Mᵢ 是 Nᵢ 的逆元）

2. 则解为：
   ```
   x = (a₁N₁M₁ + a₂N₂M₂ + ... + aₖNₖMₖ) mod N
   ```

### 8.4 示例

求解：
```
x ≡ 2 (mod 3)
x ≡ 3 (mod 5)
x ≡ 2 (mod 7)
```

**步骤**：

1. `N = 3×5×7 = 105`
   - `N₁ = 105/3 = 35`
   - `N₂ = 105/5 = 21`
   - `N₃ = 105/7 = 15`

2. 求逆元：
   - `M₁`: 35M₁ ≡ 1 (mod 3) → 2M₁ ≡ 1 (mod 3) → M₁ = 2
   - `M₂`: 21M₂ ≡ 1 (mod 5) → 1M₂ ≡ 1 (mod 5) → M₂ = 1
   - `M₃`: 15M₃ ≡ 1 (mod 7) → 1M₃ ≡ 1 (mod 7) → M₃ = 1

3. 计算：
   ```
   x = (2×35×2 + 3×21×1 + 2×15×1) mod 105
     = (140 + 63 + 30) mod 105
     = 233 mod 105
     = 23
   ```

**验证**：
```
23 mod 3 = 2 ✓
23 mod 5 = 3 ✓
23 mod 7 = 2 ✓
```

### 8.5 代码实现

```cpp
long long CRT(vector<long long> a, vector<long long> n) {
    int k = a.size();
    long long N = 1;
    for (int i = 0; i < k; i++) N *= n[i];
    
    long long result = 0;
    for (int i = 0; i < k; i++) {
        long long Ni = N / n[i];
        long long Mi = mod_inverse(Ni, n[i]);
        result = (result + a[i] * Ni % N * Mi % N) % N;
    }
    
    return (result % N + N) % N;
}
```

---

## 9. 实战应用

### 9.1 大数取模

**问题**：计算 `(a × b) mod n`，其中 a, b 很大（接近 long long 上限）

**解决**：使用快速乘（类似快速幂）

```cpp
long long mul_mod(long long a, long long b, long long mod) {
    long long result = 0;
    a %= mod;
    while (b > 0) {
        if (b & 1) result = (result + a) % mod;
        a = (a + a) % mod;
        b >>= 1;
    }
    return result;
}
```

或使用 `__int128`（GCC）：
```cpp
long long mul_mod(long long a, long long b, long long mod) {
    return (__int128)a * b % mod;
}
```

### 9.2 组合数取模

**问题**：计算 `C(n, m) mod p`（p 为质数）

**方法**：
```
C(n, m) = n! / (m! × (n-m)!)
        ≡ n! × (m!)⁻¹ × ((n-m)!)⁻¹ (mod p)
```

**代码**：
```cpp
long long C(long long n, long long m, long long p) {
    if (m > n) return 0;
    if (m == 0 || m == n) return 1;
    
    // 预处理阶乘
    vector<long long> fac(n + 1);
    fac[0] = 1;
    for (int i = 1; i <= n; i++) {
        fac[i] = fac[i-1] * i % p;
    }
    
    // C(n,m) = n! / (m! × (n-m)!)
    long long result = fac[n];
    result = result * power_mod(fac[m], p - 2, p) % p;
    result = result * power_mod(fac[n-m], p - 2, p) % p;
    
    return result;
}
```

### 9.3 矩阵快速幂

**应用**：斐波那契数列第 n 项 mod p

**原理**：
```
[F(n+1)]   [1 1]^n   [1]
[F(n)  ] = [1 0]   × [0]
```

**代码框架**：
```cpp
struct Matrix {
    long long a[2][2];
    long long mod;
    
    Matrix operator*(const Matrix& other) const {
        Matrix result;
        result.mod = mod;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                result.a[i][j] = 0;
                for (int k = 0; k < 2; k++) {
                    result.a[i][j] = (result.a[i][j] + a[i][k] * other.a[k][j]) % mod;
                }
            }
        }
        return result;
    }
};

Matrix matrix_power(Matrix base, long long exp) {
    Matrix result;
    result.mod = base.mod;
    result.a[0][0] = result.a[1][1] = 1;
    result.a[0][1] = result.a[1][0] = 0;
    
    while (exp > 0) {
        if (exp & 1) result = result * base;
        base = base * base;
        exp >>= 1;
    }
    return result;
}
```

### 9.4 RSA 加密（简化版）

**原理**：
```
加密：c = m^e mod n
解密：m = c^d mod n
其中 e×d ≡ 1 (mod φ(n))
```

**示例**：
```cpp
// 公钥：(e, n)
// 私钥：(d, n)
long long encrypt(long long message, long long e, long long n) {
    return power_mod(message, e, n);
}

long long decrypt(long long cipher, long long d, long long n) {
    return power_mod(cipher, d, n);
}
```

---

## 10. 常见陷阱

### 负数取模

**问题**：不同语言对负数取模的定义不同

```cpp
// C++
-7 % 3 = -1  // 注意是负数！

// 正确做法
int safe_mod(int a, int n) {
    return ((a % n) + n) % n;
}
// safe_mod(-7, 3) = 2
```

