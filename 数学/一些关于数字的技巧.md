# **用类型转换取某数的整数：**

```c
double a = 3.75;
int b = int(a);  // 或者 (int)a
cout << b << endl;
```

     b = 3

# 交换数字

```c
#include <utility>

if (a > b) (swap)(a, b);
if (b > c) (swap)(b, c);
if (a > b) (swap)(a, b);
```

swap：交换数值

前两部确保c的值最大，最后一步确保b大于a，使得a<b<c

# **向下取整:**

```c
int floor(int a, int b) {
     return a / b;
}
```

# 向上取整:

```c
int ceil (int a, int b) {
    if a / b * b < a {
        return a / b + 1;    
    }
    return a / b;
}
```

- a / b * b 是**向下取整**后再乘回来，看结果是不是还小于原来的 a。

- 如果小于，说明有“余数”存在，**需要+1** 来向上取整。

- 否则，说明正好整除，不用加。

# 四舍五入：

```cpp
#include <iostream>
#include <cmath> // for round()
using namespace std;
int main() {
double x;
cin >> x;
cout << round(x) << endl;
return 0;
}
```

```cpp
cout << int(x + 0.5); //老式方法
```

# **两数的最大公约数（GCD)：**

欧几里得算法（辗转相除法）

🎒 故事版解释：装书包的烦恼

你有两捆书，一捆有 **48 本**，另一捆有 **18 本**。

你想用一些**一样大小的袋子**，把这两捆书都打包装起来，**每个袋子装的书本数一样多，而且要刚好装完，不能剩下。**

你想知道：**最多能用多大的袋子？**

也就是：**一个袋子最多能装多少本书，才能正好分完 48 和 18 本？**

🧠 你开始想：

你先试试用 18 本书装袋子来装 48 本书：

- 一袋能装 18 本，那 48 ÷ 18 = 2 袋，还剩下 **12 本没装下**。

这个时候你就发现：18 装不完 48，那么你就去看 **剩下的 18 和 12** —— 因为现在你面对的是：

> **能不能把 18 和 12 都用同样大小的袋子装完？**

你又试试看：用 12 本来装 18 本：

- 18 ÷ 12 = 1 袋，还剩 **6 本没装下**

又换成：

> **现在我得同时装完 12 和 6 本书了！**

继续：

- 12 ÷ 6 = 2 袋，**刚好装完！🎉**

这说明：

> ✅ 6 是最大的袋子容量，能同时装完 48 本书和 18 本书，而且不剩！

```cpp
int GCD(int a, int b) {
    while (a % b) {
        int tmp = b;
        b = a % b;
        a = tmp;
    }
    return b;
}
//公式：辗转相除到 r 为 0，再取 b 为 gcd。
```

# 数组的最大公约数

```cpp
long long g = v[0];
for (int i = 0; i < n; i++) {
    g = GCD(g, v[i]);
}
```

### 为什么这个逻辑成立？

数学上有一个性质（非常关键）：

> **GCD(a, b, c)** = **GCD(GCD(a, b), c)**

也就是说：

- 你先算前两个数的最大公约数；

- 再用这个结果去和第三个数求 GCD；

- 结果仍然是这三个数的最大公约数。

因此，我们可以用循环“滚动地”求整个数组的 GCD。

# 求两数公约数的数量

公约数数量 = GCD约数数量

因为：

> 任何能整除 g 的数，必然能同时整除 a 和 b。

# 两数最小公倍数（LCM)

LCM(a, b) * GCD(a, b) = a * b

# 最大真约数 * 最小质因数 = n

# 求某数的正因数个数

```cpp
int count = 0;
for (int i = 1; i * i <= g; i++) {
    if (g % i == 0) {
        count++; //算上因数i
        if (i != g / i) count++;  
        //算上与i相乘等于g的另一个因数      
    }
}
```

# **取个位数**

```cpp
n % 10; //取个位数
n / 10; //去掉右边一位数
```

# **绝对值**

```cpp
int n = -1;
cout << abs(n);
```

# 向上下取整在整数除法中

假设整数 A, C > 0，想计算：

- **向下取整商**（普通整数除法）：

```
q = A / C
```

这会自动向下取整（floor），得到不大于 A/C 的整数。

- **向上取整商**（求不小于 A/C 的最小整数）：

```
q = (A + C - 1) / C
```

减1的作用

- C - 1 是为了确保当 A 恰好是 C 的倍数时，不会多加 1。

- 如果直接写 (A + C) / C，当 A 是 C 的倍数时会错误地向上加 1。

例子

A = 123, C = 100

- 向下取整：

```
123 / 100 = 1
```

- 向上取整：

```
(123 + 100 - 1) / 100 = 222 / 100 = 2
```

A = 200, C = 100 （恰好是倍数）

- 向下取整：

```
200 / 100 = 2
```

- 向上取整（用减1的写法）：

```
(200 + 100 - 1) / 100 = 299 / 100 = 2   // 正确
```

- 如果不减1，写成 (200 + 100) / 100 = 300 / 100 = 3，结果就错了。

# 找不同质因数的个数

```cpp
int prime_divisors(int n) {
    int count = 0;
    int temp = n;

        // 从2开始，检查所有可能的质因数，直到 sqrt(temp)
    for (int i = 2; i <= (int)sqrt(temp); i++) {
        // 如果 i 是 temp 的质因数
        if (temp % i == 0) count++; // 不同质因数数量加1

        // 把 temp 中所有 i 的因子都除掉，避免重复计数
        while (temp % i == 0) {
            temp /= i;
        }
    }
    // 如果循环结束后，temp > 1，说明temp本身是一个质数，
    // 这也算作一个不同质因数
    if (temp > 1) count ++;
    return count;
}
```

❓为什么可以不判断 i 是不是质数？

因为这段代码的逻辑是：

- **如果 ****i**** 能整除 ****temp****，就说明它是 ****temp**** 的一个因数**；

- 然后把 i 除尽（while (temp % i == 0)），说明把所有这个因数的幂都消掉了；

- **只要 ****i**** 能整除一次，就算作一个“不同质因数”**；

- **非质数（比如 4、6、8）无法整除已经被前面的更小因数除尽的数，所以不会重复计数**。