# 差分数组完全指南

## 一、核心思想

### 1.1 本质理解

差分数组是一种**记录变化趋势**的数据结构：

- **原数组 a[]**：存储实际的值
- **差分数组 diff[]**：存储相邻元素的**变化量**（增长速率）

```
diff[i] = a[i] - a[i-1]
```

### 1.2 直观类比

**爬山模型**：
- 原数组 = 海拔高度
- 差分数组 = 坡度变化
- 前缀和 = 累积坡度得到最终高度

**存钱模型**：
- 原数组 = 账户余额
- 差分数组 = 每天存钱速度的变化
- 前缀和 = 累积每天的存款变化

### 1.3 数学视角

- **差分** ≈ 离散的导数（derivative）
- **前缀和** ≈ 离散的积分（integral）

```
构造差分：diff[i] = a[i] - a[i-1]  （求导）
还原数组：a[i] = Σ diff[j]          （积分）
```

---

## 二、解决的问题

### 2.1 问题场景

**经典问题**：给定数组 a[]，需要进行 q 次区间修改操作：
- 每次将区间 [L, R] 的所有元素加上 x

**朴素解法**：
```cpp
for (int i = L; i <= R; i++) {
    a[i] += x;
}
```
- 单次操作：O(R - L + 1)
- q 次操作：O(q × n)

**差分优化**：
```cpp
diff[L] += x;
diff[R + 1] -= x;
```
- 单次操作：O(1)
- q 次操作 + 一次还原：O(q + n)

### 2.2 优势对比

| 操作类型 | 朴素解法 | 差分数组 |
|---------|---------|---------|
| 单次区间修改 | O(n) | O(1) |
| q 次区间修改 | O(q×n) | O(q) |
| 单点查询 | O(1) | O(n) |
| 全部查询 | O(n) | O(n) |

**适用场景**：
- ✅ 多次区间修改 + 一次性查询所有结果
- ❌ 频繁的单点查询（考虑线段树/树状数组）

---

## 三、一维差分

### 3.1 基本原理

**目标**：让区间 [L, R] 的所有元素加上 x

**差分标记**：
```cpp
diff[L] += x;      // 从 L 开始，增长速率 +x
diff[R + 1] -= x;  // 从 R+1 开始，增长速率 -x
```

**还原过程**：
```cpp
for (int i = 1; i <= n; i++) {
    diff[i] += diff[i - 1];  // 前缀和
    a[i] += diff[i];         // 应用变化
}
```

### 3.2 图解示例

```
原数组:  [0, 0, 0, 0, 0, 0]
         0  1  2  3  4  5

操作1: 区间 [1, 3] 加 5
diff:   [0, +5, 0, 0, -5, 0, 0]
前缀和:  0   5  5  5   0  0  0
结果:   [0, 5, 5, 5, 0, 0]

操作2: 区间 [2, 4] 加 3
diff:   [0, +5, +3, 0, -5, -3, 0]
前缀和:  0   5   8  8   3   0  0
结果:   [0, 5, 8, 8, 3, 0]
```

### 3.3 算法模板

#### 模板一：基础差分（从0开始）

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Difference {
private:
    vector<long long> diff;
    int n;
    
public:
    // 构造函数：n为数组长度
    Difference(int size) : n(size), diff(size + 2, 0) {}
    
    // 从原数组构造差分数组
    Difference(const vector<int>& a) {
        n = a.size();
        diff.resize(n + 2, 0);
        for (int i = 0; i < n; i++) {
            diff[i] = (i == 0) ? a[i] : (a[i] - a[i - 1]);
        }
    }
    
    // 区间 [L, R] 加上 x
    void rangeAdd(int L, int R, long long x) {
        diff[L] += x;
        diff[R + 1] -= x;
    }
    
    // 还原并获取结果数组
    vector<long long> getResult() {
        vector<long long> result(n);
        long long cumsum = 0;
        for (int i = 0; i < n; i++) {
            cumsum += diff[i];
            result[i] = cumsum;
        }
        return result;
    }
    
    // 还原到原数组（原地修改）
    void applyTo(vector<int>& a) {
        long long cumsum = 0;
        for (int i = 0; i < n; i++) {
            cumsum += diff[i];
            a[i] += cumsum;
        }
    }
};

int main() {
    int n = 6;
    vector<int> a(n, 0);  // 初始化为0
    
    Difference diff(a);
    
    // 操作1: [1, 3] 加 5
    diff.rangeAdd(1, 3, 5);
    
    // 操作2: [2, 4] 加 3
    diff.rangeAdd(2, 4, 3);
    
    // 获取结果
    vector<long long> result = diff.getResult();
    
    for (int i = 0; i < n; i++) {
        cout << result[i] << " ";
    }
    // 输出: 0 5 8 8 3 0
    
    return 0;
}
```

#### 模板二：简洁版（从1开始）

```cpp
#include <iostream>
using namespace std;

const int MAXN = 100005;
long long diff[MAXN];
int a[MAXN];
int n, q;

// 区间 [L, R] 加 x
void rangeAdd(int L, int R, int x) {
    diff[L] += x;
    diff[R + 1] -= x;
}

// 还原数组
void restore() {
    for (int i = 1; i <= n; i++) {
        diff[i] += diff[i - 1];
        a[i] += diff[i];
    }
}

int main() {
    cin >> n >> q;
    
    // 读入原数组
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    
    // 处理 q 次操作
    for (int i = 0; i < q; i++) {
        int L, R, x;
        cin >> L >> R >> x;
        rangeAdd(L, R, x);
    }
    
    // 还原并输出
    restore();
    for (int i = 1; i <= n; i++) {
        cout << a[i] << " ";
    }
    
    return 0;
}
```

---

## 四、二维差分

### 4.1 问题扩展

**目标**：对子矩阵 (x1, y1) 到 (x2, y2) 的所有元素加上 c

### 4.2 核心思想

二维差分是一维差分的扩展，记录**二维平面上的变化趋势**。

**差分标记**（容斥原理）：
```cpp
diff[x1][y1] += c;           // 左上角：开始增加
diff[x1][y2 + 1] -= c;       // 右上角外：停止右边的增加
diff[x2 + 1][y1] -= c;       // 左下角外：停止下边的增加
diff[x2 + 1][y2 + 1] += c;   // 右下角外：补偿多减的部分
```

### 4.3 图解示例

```
原矩阵 (3x3):
0 0 0
0 0 0
0 0 0

对子矩阵 (1,1) 到 (2,2) 加 5:

差分标记:
+5  0  -5
 0  0   0
-5  0  +5

二维前缀和后:
+5 +5  0
+5 +5  0
 0  0  0

结果:
5 5 0
5 5 0
0 0 0
```

### 4.4 算法模板

```cpp
#include <iostream>
using namespace std;

const int MAXN = 1005;
long long diff[MAXN][MAXN];
int a[MAXN][MAXN];
int n, m, q;

// 对子矩阵 (x1,y1) 到 (x2,y2) 加 c
void rangeAdd2D(int x1, int y1, int x2, int y2, int c) {
    diff[x1][y1] += c;
    diff[x1][y2 + 1] -= c;
    diff[x2 + 1][y1] -= c;
    diff[x2 + 1][y2 + 1] += c;
}

// 还原二维数组（二维前缀和）
void restore2D() {
    // 先对每一行做前缀和
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            diff[i][j] += diff[i][j - 1];
        }
    }
    
    // 再对每一列做前缀和
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            diff[i][j] += diff[i - 1][j];
            a[i][j] += diff[i][j];
        }
    }
}

int main() {
    cin >> n >> m >> q;
    
    // 读入原矩阵
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
        }
    }
    
    // 处理 q 次操作
    for (int i = 0; i < q; i++) {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        rangeAdd2D(x1, y1, x2, y2, c);
    }
    
    // 还原并输出
    restore2D();
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cout << a[i][j] << " ";
        }
        cout << "\n";
    }
    
    return 0;
}
```

---

## 五、经典例题

### 5.1 区间加法（一维）

**问题**：给定数组和 q 次操作，每次将 [L, R] 加 x，求最终数组。

**洛谷 P3372** / **AcWing 797**

```cpp
#include <iostream>
using namespace std;

const int MAXN = 100005;
long long diff[MAXN];
long long a[MAXN];
int n, q;

int main() {
    cin >> n >> q;
    
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    
    while (q--) {
        int L, R;
        long long x;
        cin >> L >> R >> x;
        diff[L] += x;
        diff[R + 1] -= x;
    }
    
    for (int i = 1; i <= n; i++) {
        diff[i] += diff[i - 1];
        a[i] += diff[i];
        cout << a[i] << " ";
    }
    
    return 0;
}
```

### 5.2 航班预订统计

**LeetCode 1109**

有 n 个航班，第 i 次预订包含 [first, last, seats]，表示从 first 到 last 的每个航班预订 seats 个座位。返回每个航班的预订总数。

```cpp
class Solution {
public:
    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
        vector<long long> diff(n + 2, 0);
        
        // 差分标记
        for (auto& booking : bookings) {
            int first = booking[0];
            int last = booking[1];
            int seats = booking[2];
            diff[first] += seats;
            diff[last + 1] -= seats;
        }
        
        // 前缀和还原
        vector<int> result(n);
        long long cumsum = 0;
        for (int i = 1; i <= n; i++) {
            cumsum += diff[i];
            result[i - 1] = cumsum;
        }
        
        return result;
    }
};
```

### 5.3 拼车

**LeetCode 1094**

汽车容量为 capacity，有若干行程 [numPassengers, from, to]，判断能否完成所有行程。

```cpp
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        vector<int> diff(1001, 0);
        
        // 差分标记
        for (auto& trip : trips) {
            int num = trip[0];
            int from = trip[1];
            int to = trip[2];
            diff[from] += num;      // 上车
            diff[to] -= num;        // 下车
        }
        
        // 前缀和检查
        int passengers = 0;
        for (int i = 0; i < 1001; i++) {
            passengers += diff[i];
            if (passengers > capacity) {
                return false;
            }
        }
        
        return true;
    }
};
```

### 5.4 区间加法（二维）

**AcWing 798**

```cpp
#include <iostream>
using namespace std;

const int MAXN = 1005;
long long diff[MAXN][MAXN];
int a[MAXN][MAXN];
int n, m, q;

void rangeAdd2D(int x1, int y1, int x2, int y2, int c) {
    diff[x1][y1] += c;
    diff[x1][y2 + 1] -= c;
    diff[x2 + 1][y1] -= c;
    diff[x2 + 1][y2 + 1] += c;
}

int main() {
    cin >> n >> m >> q;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
        }
    }
    
    while (q--) {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        rangeAdd2D(x1, y1, x2, y2, c);
    }
    
    // 二维前缀和还原
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            diff[i][j] += diff[i][j - 1];
        }
    }
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            diff[i][j] += diff[i - 1][j];
            a[i][j] += diff[i][j];
            cout << a[i][j] << " ";
        }
        cout << "\n";
    }
    
    return 0;
}
```

---

## 六、进阶技巧

### 6.1 树上差分

**应用场景**：树的路径批量修改

**核心思想**：
- 路径 u → v 可以分解为 u → LCA → v
- 使用差分标记 + DFS 求前缀和

```cpp
// 路径 u -> v 加 x
void pathAdd(int u, int v, int x) {
    int lca = LCA(u, v);
    diff[u] += x;
    diff[v] += x;
    diff[lca] -= x;
    diff[father[lca]] -= x;
}

// DFS 求子树和
void dfs(int u, int fa) {
    for (int v : g[u]) {
        if (v == fa) continue;
        dfs(v, u);
        diff[u] += diff[v];  // 子树的差分累加到父节点
    }
}
```

### 6.2 差分 + 前缀和组合

**问题**：区间修改 + 区间查询

**解法**：差分优化修改，前缀和优化查询

```cpp
// 修改：差分
diff[L] += x;
diff[R + 1] -= x;

// 查询区间 [L, R] 的和
// 先还原数组
for (int i = 1; i <= n; i++) {
    diff[i] += diff[i - 1];
    a[i] += diff[i];
}

// 再用前缀和查询
sum[i] = sum[i - 1] + a[i];
query(L, R) = sum[R] - sum[L - 1];
```

---

## 七、常见错误

### 7.1 边界问题

❌ **错误**：
```cpp
diff[R + 1] -= x;  // 可能越界
```

✅ **正确**：
```cpp
vector<long long> diff(n + 2, 0);  // 多开一个位置
```

### 7.2 忘记还原

❌ **错误**：
```cpp
// 直接输出差分数组
for (int i = 1; i <= n; i++) {
    cout << diff[i] << " ";  // 错误！
}
```

✅ **正确**：
```cpp
// 必须先还原
for (int i = 1; i <= n; i++) {
    diff[i] += diff[i - 1];
    a[i] += diff[i];
    cout << a[i] << " ";
}
```

### 7.3 数据溢出

❌ **错误**：
```cpp
int diff[MAXN];  // 可能溢出
```

✅ **正确**：
```cpp
long long diff[MAXN];  // 使用 long long
```

---

## 八、总结

### 8.1 核心记忆

> **差分数组 = 变化率 = 离散导数**

- `diff[L] += x`：从 L 开始加速增长
- `diff[R + 1] -= x`：从 R+1 开始减速增长
- 前缀和：累积所有变化率，得到最终值

### 8.2 适用场景

✅ **适合**：
- 多次区间修改，最后一次性查询
- 静态数据的批量更新

❌ **不适合**：
- 频繁的单点查询（用线段树/树状数组）
- 需要在线查询（用线段树）

### 8.3 时间复杂度

- 单次区间修改：O(1)
- m 次修改 + 还原：O(m + n)
- 二维差分：O(m + n²)

### 8.4 记忆口诀

```
差分数组记趋势，
起点加来终点减，
前缀累积得结果，
区间修改变 O(1)。
```

---

## 九、练习题目

### 基础题
- 洛谷 P3372：线段树（差分是特例）
- AcWing 797：差分
- LeetCode 1109：航班预订统计
- LeetCode 1094：拼车

### 进阶题
- AcWing 798：差分矩阵
- 洛谷 P2357：守墓人
- LeetCode 370：区间加法（会员题）

### 树上差分
- 洛谷 P3128：最大流
- 洛谷 P2680：运输计划