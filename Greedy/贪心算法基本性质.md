# 贪心算法(Greedy Algorithm)

## 定义

贪心算法是一种在每一步选择中都采取当前状态下**最优(最有利)的选择**,从而希望导致结果是全局最优的算法策略。它不会回溯,也不考虑未来的影响,只关注当前的最佳决策。

## 核心特征

1. **贪心选择性质(Greedy Choice Property)**
   - 每一步都做出局部最优选择
   - 不需要回溯或重新考虑之前的选择
   - 通过局部最优达到全局最优
2. **最优子结构(Optimal Substructure)**
   - 问题的最优解包含其子问题的最优解
   - 可以通过子问题的最优解推导出原问题的最优解
3. **无后效性**
   - 某个状态之后的过程不会影响以前的状态
   - 只与当前状态有关
4. **不一定得到全局最优解**
   - 贪心算法不保证对所有问题都能得到最优解
   - 需要证明贪心策略的正确性

## 基本用法示例

### 1. **找零钱问题**

cpp

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> coinChangeGreedy(int amount, vector<int>& coins) {
    // 从大到小排序
    sort(coins.begin(), coins.end(), greater<int>());
    
    vector<int> result;
    
    for (int coin : coins) {
        while (amount >= coin) {
            amount -= coin;
            result.push_back(coin);
        }
    }
    
    return result;
}

int main() {
    vector<int> coins = {25, 10, 5, 1};
    int amount = 63;
    
    vector<int> result = coinChangeGreedy(amount, coins);
    
    cout << "找零方案: ";
    for (int coin : result) {
        cout << coin << " ";
    }
    cout << endl;
    
    return 0;
}
```

### 2. **活动选择问题(区间调度)**

cpp

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Activity {
    int start;
    int end;
    
    Activity(int s, int e) : start(s), end(e) {}
};

// 按结束时间排序
bool compareByEnd(const Activity& a, const Activity& b) {
    return a.end < b.end;
}

vector<Activity> activitySelection(vector<Activity>& activities) {
    // 按结束时间排序(贪心策略)
    sort(activities.begin(), activities.end(), compareByEnd);
    
    vector<Activity> selected;
    selected.push_back(activities[0]);
    int lastEnd = activities[0].end;
    
    for (int i = 1; i < activities.size(); i++) {
        if (activities[i].start >= lastEnd) {
            selected.push_back(activities[i]);
            lastEnd = activities[i].end;
        }
    }
    
    return selected;
}

int main() {
    vector<Activity> activities = {
        Activity(1, 3),
        Activity(2, 5),
        Activity(4, 7),
        Activity(6, 9),
        Activity(8, 10)
    };
    
    vector<Activity> selected = activitySelection(activities);
    
    cout << "选中的活动: " << endl;
    for (const auto& act : selected) {
        cout << "[" << act.start << ", " << act.end << "] ";
    }
    cout << endl;
    
    return 0;
}
```

### 3. **分数背包问题**

cpp

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Item {
    int value;
    int weight;
    
    Item(int v, int w) : value(v), weight(w) {}
    
    // 计算单位重量价值
    double unitValue() const {
        return (double)value / weight;
    }
};

bool compareByUnitValue(const Item& a, const Item& b) {
    return a.unitValue() > b.unitValue();
}

double fractionalKnapsack(int capacity, vector<Item>& items) {
    // 按单位重量价值排序(贪心策略)
    sort(items.begin(), items.end(), compareByUnitValue);
    
    double totalValue = 0.0;
    
    for (const auto& item : items) {
        if (capacity >= item.weight) {
            // 完全装入
            capacity -= item.weight;
            totalValue += item.value;
        } else {
            // 部分装入
            totalValue += item.value * ((double)capacity / item.weight);
            break;
        }
    }
    
    return totalValue;
}

int main() {
    vector<Item> items = {
        Item(60, 10),
        Item(100, 20),
        Item(120, 30)
    };
    int capacity = 50;
    
    double maxValue = fractionalKnapsack(capacity, items);
    cout << "最大价值: " << maxValue << endl;
    
    return 0;
}
```

### 4. **霍夫曼编码(Huffman Coding)**

cpp

```cpp
#include <iostream>
#include <queue>
#include <unordered_map>
#include <string>
using namespace std;

struct Node {
    char ch;
    int freq;
    Node* left;
    Node* right;
    
    Node(char c, int f) : ch(c), freq(f), left(nullptr), right(nullptr) {}
};

// 优先队列比较器
struct Compare {
    bool operator()(Node* a, Node* b) {
        return a->freq > b->freq; // 最小堆
    }
};

void generateCodes(Node* root, string code, unordered_map<char, string>& codes) {
    if (!root) return;
    
    if (!root->left && !root->right) {
        codes[root->ch] = code;
    }
    
    generateCodes(root->left, code + "0", codes);
    generateCodes(root->right, code + "1", codes);
}

unordered_map<char, string> huffmanEncoding(const string& text) {
    // 统计频率
    unordered_map<char, int> freq;
    for (char ch : text) {
        freq[ch]++;
    }
    
    // 创建优先队列(最小堆)
    priority_queue<Node*, vector<Node*>, Compare> pq;
    for (auto& p : freq) {
        pq.push(new Node(p.first, p.second));
    }
    
    // 构建霍夫曼树(贪心策略:每次合并频率最小的两个节点)
    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();
        
        Node* merged = new Node('\0', left->freq + right->freq);
        merged->left = left;
        merged->right = right;
        
        pq.push(merged);
    }
    
    // 生成编码
    unordered_map<char, string> codes;
    generateCodes(pq.top(), "", codes);
    
    return codes;
}

int main() {
    string text = "hello world";
    
    auto codes = huffmanEncoding(text);
    
    cout << "霍夫曼编码: " << endl;
    for (auto& p : codes) {
        cout << p.first << ": " << p.second << endl;
    }
    
    return 0;
}
```

### 5. **最小生成树 - Kruskal算法**

cpp

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Edge {
    int u, v, weight;
    
    Edge(int u, int v, int w) : u(u), v(v), weight(w) {}
    
    bool operator<(const Edge& other) const {
        return weight < other.weight;
    }
};

class UnionFind {
private:
    vector<int> parent;
    
public:
    UnionFind(int n) : parent(n) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }
    
    bool unite(int x, int y) {
        int px = find(x);
        int py = find(y);
        
        if (px != py) {
            parent[px] = py;
            return true;
        }
        return false;
    }
};

pair<vector<Edge>, int> kruskal(int n, vector<Edge>& edges) {
    // 按权重排序(贪心策略)
    sort(edges.begin(), edges.end());
    
    UnionFind uf(n);
    vector<Edge> mst;
    int totalWeight = 0;
    
    for (const auto& edge : edges) {
        if (uf.unite(edge.u, edge.v)) { // 不形成环
            mst.push_back(edge);
            totalWeight += edge.weight;
        }
    }
    
    return {mst, totalWeight};
}

int main() {
    int n = 4; // 节点数
    vector<Edge> edges = {
        Edge(0, 1, 1),
        Edge(0, 2, 2),
        Edge(1, 2, 3),
        Edge(1, 3, 4),
        Edge(2, 3, 5)
    };
    
    auto [mst, weight] = kruskal(n, edges);
    
    cout << "最小生成树的边: " << endl;
    for (const auto& edge : mst) {
        cout << edge.u << " - " << edge.v << " (权重: " << edge.weight << ")" << endl;
    }
    cout << "总权重: " << weight << endl;
    
    return 0;
}
```

### 6. **跳跃游戏**

cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

bool canJump(vector<int>& nums) {
    int maxReach = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        if (i > maxReach) return false; // 无法到达当前位置
        
        // 贪心:更新能到达的最远位置
        maxReach = max(maxReach, i + nums[i]);
        
        if (maxReach >= nums.size() - 1) return true;
    }
    
    return false;
}

int main() {
    vector<int> nums = {2, 3, 1, 1, 4};
    
    if (canJump(nums)) {
        cout << "可以到达终点" << endl;
    } else {
        cout << "无法到达终点" << endl;
    }
    
    return 0;
}
```

## 时间复杂度对比

```
问题时间复杂度空间复杂度
找零钱O(n)O(n)
活动选择O(n log n)O(n)
分数背包O(n log n)O(1)
霍夫曼编码O(n log n)O(n)
Kruskal算法O(E log E)O(V)
```

## 适用场景

✅ **适合贪心算法:**

- 活动选择/区间调度
- 霍夫曼编码
- 最小生成树(Kruskal, Prim)
- 单源最短路径(Dijkstra)
- 分数背包问题

❌ **不适合贪心算法:**

- 0/1背包问题(需要动态规划)
- 旅行商问题(TSP)
- 最长公共子序列

## 关键要点

使用贪心算法前需要验证:

1. **贪心选择性质** - 局部最优能否导致全局最优
2. **最优子结构** - 是否具有递归性质
3. **正确性证明** - 数学归纳法或交换论证