https://codeforces.com/contest/2167/problem/E

![](C:\Users\24940\Desktop\C++笔记\Binary search\images\Untitld.png)

```cpp
// 二分答案法：对最大化最小值进行二分
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

// 定义区间结构体，表示一个闭区间 [left, right]
struct interval{
    long long left;
    long long right;
};

// 比较函数：按区间左端点从小到大排序
bool compareintervals(const interval& a, const interval& b) {
    return a.left < b.left;
}

/**
 * 检查函数：判断是否能选出 k 个位置，使得最小距离 >= mid
 * @param mid 当前二分的距离值
 * @param v 禁止点的位置数组
 * @param x 坐标范围 [0, x]
 * @param k 需要选择的点的数量
 * @return 如果可以选出 k 个点使得最小距离 >= mid，返回 true
 */
bool check(long long mid, vector<long long>& v, long long x, long long k) {
    // 1. 构建禁止区域：对于每个禁止点，计算距离小于 mid 的区域
    vector<interval> forbidden_regions;
    for (int i = 0; i < v.size(); i++) {
        // 如果距离 < mid，即 |pos - v[i]| < mid
        // 则 v[i] - mid < pos < v[i] + mid
        // 禁止区域为 [v[i] - mid + 1, v[i] + mid - 1]
        long long l = max((long long)0, v[i] - mid + 1);
        long long r = min(x, v[i] + mid - 1);
        if(l <= r) forbidden_regions.push_back({l, r});
    }

    // 2. 如果没有禁止区域，所有位置都可选
    if (forbidden_regions.empty()) {
        return x + 1 >= k; // 总共有 x+1 个位置（0 到 x）
    }

    // 3. 对禁止区域按左端点排序
    sort(forbidden_regions.begin(), forbidden_regions.end(), compareintervals);

    // 4. 合并重叠的禁止区域
    vector<interval> merged_regions;
    merged_regions.push_back(forbidden_regions[0]);
    for (int i = 1; i < forbidden_regions.size(); i++) {
        const interval& current = forbidden_regions[i];
        interval& last = merged_regions.back();
        
        // 如果当前区间与上一个区间重叠或相邻，则合并
        if (current.left <= last.right + 1) {
            last.right = max(last.right, current.right);
        } else {
            // 否则添加为新的独立区间
            merged_regions.push_back(current);
        }
    }

    // 5. 计算可选位置的数量（非禁止区域的点数）
    long long cnt = 0;
    long long pos = 0; // 当前扫描位置
    
    // 遍历每个禁止区域，统计区域之前的可选点
    for(const interval& region : merged_regions) {
        cnt += max(0LL, region.left - pos); // 从 pos 到区间左端点前的可选点
        pos = region.right + 1; // 跳过禁止区域
    }
    // 加上最后一个禁止区域之后的可选点
    cnt += max(0LL, (x + 1) - pos);

    // 6. 判断可选位置是否 >= k
    return cnt >= k;
}

/**
 * 获取合并后的禁止区域
 * @param left 最优距离值
 * @param v 禁止点的位置数组
 * @param x 坐标范围
 * @param k 需要选择的点数
 * @return 合并后的禁止区域列表
 */
vector<interval> get_merged_regions(long long left, vector<long long>& v, long long x, long long k) {
    // 构建禁止区域
    vector<interval> forbidden_regions;
    for (int i = 0; i < v.size(); i++) {
        long long l = max((long long)0, v[i] - left + 1);
        long long r = min(x, v[i] + left - 1);
        if (l <= r) forbidden_regions.push_back({l, r});
    }

    // 如果没有禁止区域，返回空
    if (empty(forbidden_regions)) return {};

    // 排序
    sort (forbidden_regions.begin(), forbidden_regions.end(), compareintervals);

    // 合并区间
    vector<interval> merged_regions;
    merged_regions.push_back(forbidden_regions[0]);
    for (int i = 1; i < forbidden_regions.size(); i++) {
        const interval& current = forbidden_regions[i];
        interval& last = merged_regions.back();
        
        if (current.left <= last.right + 1) {
            last.right = max(last.right, current.right);;
        } else {
            merged_regions.push_back(current);
        }
    }
    return merged_regions;
}

int main() {
    // 优化输入输出速度
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t;
    cin >> t;
    
    while (t--) {
        long long n, k, x;
        cin >> n >> k >> x;

        // n 个禁止点的位置
        vector<long long> v(n);
        for (int i = 0; i < n; i++) {
            cin >> v[i];
        }

        // 二分答案：在 [0, x] 范围内找最大的最小距离
        long long left = 0;
        long long right = x;
        long long ans = 0;
        
        while (left <= right) {
            long long mid = (left + right) / 2;
            if (check(mid, v, x, k)) {
                // 如果可以达到距离 mid，尝试更大的距离
                left = mid + 1;
                ans = mid;
            }
            else right = mid - 1; // 否则缩小范围
        }

        // 根据最优答案 ans 构造输出方案
        vector <interval> merged_regions = get_merged_regions(ans, v, x, k);
        
        long long region_idx = 0;   // 当前处理的禁止区域索引
        long long print_cnt = 0;    // 已输出的点数
        long long pos = 0;          // 当前扫描位置
        
        // 从 0 开始扫描，跳过禁止区域，输出 k 个可选点
        while (print_cnt < k && pos <= x) {
            bool is_forbidden = false;
            
            // 检查当前位置是否在禁止区域内
            if (region_idx < merged_regions.size()) {
                const interval& current = merged_regions[region_idx];
                if (pos >= current.left && pos <= current.right) {
                    // 如果在禁止区域内，跳过整个区域
                    is_forbidden = true;
                    pos = current.right + 1;
                    region_idx++;
                    continue;
                }
            }

            // 如果不在禁止区域，输出该位置
            if (!is_forbidden) {
                cout << pos << ' ';
                print_cnt++;
            }

            pos++;
        }

        cout << '\n';
    }

    return 0;
}
```

