## 基础例题



### **最长合法窗口（常见：sum ≤ S，频率 ≤ K）**

- **目标：求最大长度**
- 窗口**尽可能大**，不合法时收缩

**模板：**

```cpp
ll left = 0, sum = 0, ans = 0;
for (ll right = 0; right < n; right++) {
    sum += a[right];               // 扩展窗口

    while (sum > S) {              // 不合法 → 收缩
        sum -= a[left];
        left++;
    }

    ans = max(ans, right - left + 1);  // 更新答案
}
```

▶ 用于：**Segment with Small Sum**

------



### **最短合法窗口（常见：sum ≥ S，包含所有字符）**

- **目标：求最小长度**
- 只要合法就尽可能**缩小**窗口

**模板：**

```cpp
ll left = 0, sum = 0, ans = INF;
for (ll right = 0; right < n; right++) {
    sum += a[right];

    while (sum >= S) {          // 已满足 → 考虑缩小
        ans = min(ans, right - left + 1);
        sum -= a[left];
        left++;
    }
}
```

▶ 用于：**Minimum Size Subarray Sum**

------



### **合法区间个数（sum ≤ S 型）**

> 求所有 `sum(l..r) ≤ S` 的区间数量

记住一个公式：

```
对于每个 right，
满足条件的 left ∈ [0..right-left]
数量 = right - left + 1
```

**模板：**

```cpp
ll left = 0, sum = 0, ans = 0;
for (ll right = 0; right < n; right++) {
    sum += a[right];

    while (sum > S) {
        sum -= a[left];
        left++;
    }

    ans += (right - left + 1);  // ★ 每个 right 一次性加
}
```

▶ 用于：**Number of Segments with Small Sum**

------



###  **合法区间个数（sum ≥ S 型）**

> 求所有 `sum(l..r) ≥ S` 的区间数量
>  只要出现一个合法 `(left..right)`，从 `right` 开始到 `n-1` 都合法

数量 = `(n - right)`

**模板：**

```cpp
ll left = 0, sum = 0, ans = 0;
for (ll right = 0; right < n; right++) {
    sum += a[right];

    while (sum >= S) {
        ans += (n - right);   // ★ 一次性加后面所有区间
        sum -= a[left];
        left++;
    }
}
```

▶ 用于：**Number of Segments with Big Sum**







## 进阶

### 例题1

https://codeforces.com/problemset/problem/701/C

 求合法窗口的最小值，在符合条件时更新全局最值并收缩

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <set>
using namespace std;

int main () {
    int n;
    string s;
    cin >> n >> s;

    
    set<char> se;
    for (const char& x: s) {
        se.insert(x);
    }

    int cnt_types = se.size();

    map<char, int> window_counts;

    int left = 0;
    int current_cnt_types = 0;
    int res = n;
    for (int right = 0; right < n; right++) {
        window_counts[s[right]]++;
        if (window_counts[s[right]] == 1) current_cnt_types++;

        //当窗口符合条件时，记录并更新全局最小值
        while (current_cnt_types == cnt_types) {
            int current_res = 0;
            current_res = right - left + 1;
            res = min(current_res, res);
            //尝试收缩
            window_counts[s[left]]--;
            if (window_counts[s[left]] == 0) current_cnt_types--;
            left++;
        }
    }
    
    cout << res << endl;

    return 0;    
} 
```

