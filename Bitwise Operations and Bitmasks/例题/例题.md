https://codeforces.com/problemset/problem/484/A

## **Bits**

记 $f(x)$ 为非负整数 $x$ 的二进制表示中 **被置位（即 ‘1’ 位）数量**。

给定多组查询，每组由两个整数 $l$ 和 $r$ 组成。
 对于每个查询，找出满足 $l \le x \le r$ 的 $x$，使得 $f(x)$ 的值尽可能大。
 若有多个这样的 $x$，输出其中 **最小的** 一个。

------

### **输入**

第一行包含整数 $n$ —— 查询的数量（1 ≤ n ≤ 10000）。

接下来每一行包含两个整数 $l_i, r_i$ —— 该查询的区间（0 ≤ $l_i$ ≤ $r_i$ ≤ $10^{18}$）。

------

### **输出**

对每个查询，在单独一行输出答案。

------

### **示例输入**

```
3
1 2
2 4
1 10
```

### **示例输出**

```
1
3
7
```

------

### **说明**

从 1 到 10 的二进制表示如下：

- 1₁₀ = 1₂
- 2₁₀ = 10₂
- 3₁₀ = 11₂
- 4₁₀ = 100₂
- 5₁₀ = 101₂
- 6₁₀ = 110₂
- 7₁₀ = 111₂
- 8₁₀ = 1000₂
- 9₁₀ = 1001₂
- 10₁₀ = 1010₂























## 解题思路

**贪心**

从**l**的**最低位(LSB)**开始，在合法区间内将遇到的**0**变为**1**



## 代码实现

```cpp
#include <iostream>
using namespace std;

long long solve(long long l, long long r) {
    /*
     * 贪心 + 位运算技巧
     * 
     * 核心思想：要让1的个数最多且数值最小，最优解是构造"低位连续的1"
     * 
     * 例如：l = 10 (二进制: 1010)
     * - 尝试将最低位的0变成1: 1011 (11)
     * - 继续尝试将倒数第2位的0变成1: 1111 (15)
     * 
     * 算法：从低位到高位，找到每个0位，尝试将它及以下所有位都设为1
     */
    
    // 特殊情况：如果 l = 0，从最小的连续1开始尝试
    if (l == 0) {
        // 找到最大的 2^k - 1 <= r
        long long result = 0;
        for (int bit = 0; bit <= 60; bit++) {
            long long candidate = (1LL << (bit + 1)) - 1;
            if (candidate <= r) {
                result = candidate;
            } else {
                break;
            }
        }
        return result;
    }
    
    long long result = l;
    
    // 从最低位开始遍历
    for (int bit = 0; bit <= 60; bit++) {
        // 检查第 bit 位是否为 0
        if (((l >> bit) & 1) == 0) {
            // 构造新数：保留高位，第bit位及以下全设为1
            // 例如：l = 1010, bit = 0 → candidate = 1011
            //      l = 1010, bit = 2 → candidate = 1111
            
            long long high_part = (l >> (bit + 1)) << (bit + 1);  // 保留高位
            long long low_part = (1LL << (bit + 1)) - 1;          // 低位全为1
            long long candidate = high_part | low_part;
            
            if (candidate <= r) {
                result = candidate;
            } else {
                break;  // 超出范围，停止
            }
        }
    }
    
    return result;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int n;
    cin >> n;
    
    for (int i = 0; i < n; i++) {
        long long l, r;
        cin >> l >> r;
        cout << solve(l, r) << "\n";
    }
    
    return 0;
}
```

