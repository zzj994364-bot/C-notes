# 单调队列

## 什么是单调队列？

**单调队列**是一种特殊的队列，队列中的元素保持**单调递增**或**单调递减**的顺序。

### 核心思想

> "如果一个元素永远不可能成为答案，就把它踢出队列！"
>
> 窗口内只存在"有潜力成为答案"的元素
>
> 大部分时间队列的大小远小于窗口

------

## 为什么需要单调队列？

### 问题引入：滑动窗口最大值

**题目**：给定数组 `[1,3,-1,-3,5,3,6,7]` 和窗口大小 `k=3`，求每个窗口的最大值。

```
窗口位置              最大值
[1  3  -1] -3  5  3  6  7     3
 1 [3  -1  -3] 5  3  6  7     3
 1  3 [-1  -3  5] 3  6  7     5
 1  3  -1 [-3  5  3] 6  7     5
 1  3  -1  -3 [5  3  6] 7     6
 1  3  -1  -3  5 [3  6  7]    7
```

### 朴素方法：每次遍历窗口

```cpp
// 时间复杂度：O(n*k)
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> result;
    for (int i = 0; i <= nums.size() - k; i++) {
        int maxVal = nums[i];
        for (int j = i; j < i + k; j++) {
            maxVal = max(maxVal, nums[j]);  // 每次都要遍历k个元素
        }
        result.push_back(maxVal);
    }
    return result;
}
```

**问题**：太慢了！每个窗口都要遍历k个元素。

------

## 单调队列的核心洞察

### 关键观察

```
窗口: [1, 3, -1]
```

思考：如果 `3` 在窗口内，`1` 还有可能成为最大值吗？

**答案：不可能！**

- `3 > 1`
- `3` 在 `1` 后面（当窗口滑动时，`1` 会先离开）
- 所以 `1` 永远不会是答案，可以扔掉！

### 维护策略

对于求**最大值**的单调递减队列：

1. 队首元素永远是当前窗口最大值
2. 新元素入队时，从队尾开始，**踢掉所有比它小的元素**
3. 队首元素如果不在窗口内了，就出队

------

## 图解过程

### 示例：`nums = [1,3,-1,-3,5,3,6,7]`, `k=3`

```
队列存储：下标（不是值）
队列保持：从队首到队尾，对应的值递减

步骤 1: i=0, nums[0]=1
队列: [0]  (值: [1])
窗口未满

步骤 2: i=1, nums[1]=3
3 > 1，踢掉 0
队列: [1]  (值: [3])
窗口未满

步骤 3: i=2, nums[2]=-1
-1 < 3，直接加入
队列: [1, 2]  (值: [3, -1])
窗口满了，答案 = nums[1] = 3

步骤 4: i=3, nums[3]=-3
检查队首：1 在窗口内？是的 (1 >= 3-3+1)
-3 < -1，直接加入
队列: [1, 2, 3]  (值: [3, -1, -3])
答案 = nums[1] = 3

步骤 5: i=4, nums[4]=5
检查队首：1 不在窗口内了 (1 < 4-3+1)，移除
5 > -1，踢掉 2
5 > -3，踢掉 3
队列: [4]  (值: [5])
答案 = nums[4] = 5

步骤 6: i=5, nums[5]=3
3 < 5，直接加入
队列: [4, 5]  (值: [5, 3])
答案 = nums[4] = 5

步骤 7: i=6, nums[6]=6
6 > 5，踢掉 4
6 > 3，踢掉 5
队列: [6]  (值: [6])
答案 = nums[6] = 6

步骤 8: i=7, nums[7]=7
7 > 6，踢掉 6
队列: [7]  (值: [7])
答案 = nums[7] = 7
```

------

## 完整代码实现

### 滑动窗口最大值

```cpp
#include <deque>
#include <vector>
using namespace std;

vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq;  // 存储下标
    vector<int> result;
    
    for (int i = 0; i < nums.size(); i++) {
        // 1. 移除不在窗口内的元素（队首）
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        
        // 2. 维护单调递减：移除所有比当前元素小的（队尾）
        while (!dq.empty() && nums[dq.back()] < nums[i]) {
            dq.pop_back();
        }
        
        // 3. 当前元素入队
        dq.push_back(i);
        
        // 4. 窗口形成后，记录答案
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    
    return result;
}
```

### 时间复杂度分析

- **每个元素最多入队一次，出队一次**
- 总时间复杂度：**O(n)**
- 对比朴素方法的 O(n*k)，提升巨大！

------

## 单调队列的两种类型

### 1. 单调递减队列（维护最大值）

```cpp
// 队首 → 队尾：值递减
// [5, 3, 1]  表示值：大 → 小

// 新元素入队时
while (!dq.empty() && nums[dq.back()] < nums[i]) {
    dq.pop_back();  // 踢掉比我小的
}
dq.push_back(i);

// 队首就是最大值
int maxVal = nums[dq.front()];
```

### 2. 单调递增队列（维护最小值）

```cpp
// 队首 → 队尾：值递增
// [1, 3, 5]  表示值：小 → 大

// 新元素入队时
while (!dq.empty() && nums[dq.back()] > nums[i]) {
    dq.pop_back();  // 踢掉比我大的
}
dq.push_back(i);

// 队首就是最小值
int minVal = nums[dq.front()];
```

------

## 典型应用场景

### 场景1：固定窗口的最值

```cpp
// 滑动窗口最大值/最小值
// 窗口大小固定为 k
```

### 场景2：可变窗口 + 单调性

```cpp
// 例：最短子数组，使得最大值 - 最小值 >= k
deque<int> maxDq, minDq;  // 同时维护最大最小
int left = 0;
for (int right = 0; right < n; right++) {
    // 维护最大值队列
    while (!maxDq.empty() && nums[maxDq.back()] < nums[right])
        maxDq.pop_back();
    maxDq.push_back(right);
    
    // 维护最小值队列
    while (!minDq.empty() && nums[minDq.back()] > nums[right])
        minDq.pop_back();
    minDq.push_back(right);
    
    // 收缩窗口
    while (nums[maxDq.front()] - nums[minDq.front()] >= k) {
        // 更新答案
        if (maxDq.front() == left) maxDq.pop_front();
        if (minDq.front() == left) minDq.pop_front();
        left++;
    }
}
```

### 场景3：区间DP优化

```cpp
// 某些DP问题中，转移方程涉及区间最值
// 可以用单调队列优化到 O(n)
```

------

## 单调队列 vs 其他数据结构

| 数据结构     | 查询最值 | 插入     | 删除队首 | 适用场景                   |
| ------------ | -------- | -------- | -------- | -------------------------- |
| **单调队列** | O(1)     | O(1)均摊 | O(1)     | 滑动窗口，固定/可变        |
| **优先队列** | O(1)     | O(log n) | O(log n) | 只需最值，不需删除任意元素 |
| **multiset** | O(log n) | O(log n) | O(log n) | 需要删除任意元素           |
| **暴力**     | O(k)     | O(1)     | O(1)     | 窗口很小                   |

------

## 单调队列模板

### 最大值模板

```cpp
deque<int> dq;  // 存下标，单调递减

// 添加元素
void push(int i) {
    // 维护单调性
    while (!dq.empty() && nums[dq.back()] <= nums[i]) {
        dq.pop_back();
    }
    dq.push_back(i);
}

// 移除过期元素
void pop(int left) {
    if (!dq.empty() && dq.front() < left) {
        dq.pop_front();
    }
}

// 获取最大值
int getMax() {
    return nums[dq.front()];
}
```

### 最小值模板

```cpp
deque<int> dq;  // 存下标，单调递增

// 添加元素
void push(int i) {
    // 维护单调性
    while (!dq.empty() && nums[dq.back()] >= nums[i]) {
        dq.pop_back();
    }
    dq.push_back(i);
}

// 移除过期元素
void pop(int left) {
    if (!dq.empty() && dq.front() < left) {
        dq.pop_front();
    }
}

// 获取最小值
int getMin() {
    return nums[dq.front()];
}
```

------

## 常见错误

### ❌ 错误1：存值而不是下标

```cpp
// 错误
dq.push_back(nums[i]);  // 存的是值

// 问题：无法判断元素是否还在窗口内
// 无法移除过期元素
// 正确
dq.push_back(i);  // 存下标

// 判断是否在窗口内
if (dq.front() < i - k + 1) { ... }
```

### ❌ 错误2：忘记移除过期元素

```cpp
// 错误：没有pop_front
while (!dq.empty() && nums[dq.back()] < nums[i])
    dq.pop_back();
dq.push_back(i);
// 队首可能不在窗口内了！
// 正确：先移除过期
while (!dq.empty() && dq.front() < i - k + 1)
    dq.pop_front();
while (!dq.empty() && nums[dq.back()] < nums[i])
    dq.pop_back();
dq.push_back(i);
```

### ❌ 错误3：单调性方向搞反

```cpp
// 求最大值，应该递减
while (!dq.empty() && nums[dq.back()] < nums[i])  // ✅
    dq.pop_back();

while (!dq.empty() && nums[dq.back()] > nums[i])  // ❌ 反了
    dq.pop_back();
```

------

## 练习题推荐

1. **入门**：[LeetCode 239. 滑动窗口最大值](https://claude.ai/chat/固定窗口)
2. **进阶**：[LeetCode 862. 和至少为K的最短子数组](https://claude.ai/chat/可变窗口)
3. **困难**：[LeetCode 1696. 跳跃游戏VI](https://claude.ai/chat/DP+单调队列)

------

## 记忆口诀

**单调队列三步走：**

1. **队首过期就出队**（pop_front）
2. **队尾比我弱就踢**（pop_back 维护单调性）
3. **新元素从队尾入**（push_back）

**时刻记住：**

- 存**下标**不存值
- **队首**是答案
- 每个元素最多进出一次，O(n)

------

## 总结

单调队列是**滑动窗口问题的利器**，核心在于：

1. **单调性**：维护递增或递减
2. **队首**：永远是当前最优答案
3. **高效**：每个元素最多进出一次，O(n)

记住这个原则：**"不可能成为答案的，立刻踢掉！"**