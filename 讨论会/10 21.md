模拟题：多定义函数➡分治思想，方便调试

模拟题调试：void print

```cpp
#ifndef ONLINE_JUDGE
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
#endif
```

本地运行时，会把输入输出重定向到文件；

上传到 Online Judge（如 Codeforces）时，这段代码自动被跳过，因为评测机定义了 ONLINE_JUDGE。

断点（break point）是什么？

**断点就是让程序在运行时“暂停”在某一行代码的位置。**

> 当程序运行到有断点的那一行时，它会 **停下来**，
> 你可以在这一刻查看程序内部的状态（变量、内存、调用栈等等）。

两个用pair定义，三个及以上用struct定义

## 🧩 一、struct 是什么？

struct 是 “structure”（结构体） 的缩写。

它的作用是：

> **把多个不同类型的数据打包成一个整体（结构体）。**

换句话说，struct 是一种**自定义数据结构**，

让你可以像定义变量一样，定义“由多个成员组成”的复杂类型。

## 💻 二、基本语法

```cpp
struct Student {
    string name;
    int age;
    double score;
};
```

上面这段定义了一个结构体类型 Student，

它里面有三个成员：name、age、score。

## 📦 三、怎么用它

```cpp
Student s1;             // 声明一个结构体变量
s1.name = "月月鸟";
s1.age = 18;
s1.score = 95.5;

cout << s1.name << " 的分数是 " << s1.score << endl;
```

输出：

```
月月鸟 的分数是 95.5
```

## 🧠 四、结构体有什么用？

它最大的价值是**组织数据**。

在实际开发或算法题中经常用来存储一组“相关信息”。

例如：

| 场景     | 用法                                                   |
| ------ | ---------------------------------------------------- |
| 存储学生信息 | struct Student { string name; int id; double gpa; }; |
| 存储二维坐标 | struct Point { int x, y; };                          |
| 存储比赛成绩 | struct Player { string name; int score; };           |

比用一堆平行数组更清晰、更安全。

## 🧩 五、还能放函数（C++ 扩展）

在 C++ 中，结构体不仅能存变量，还能放函数（方法）：

```cpp
struct Point {
    int x, y;

    void move(int dx, int dy) {
        x += dx;
        y += dy;
    }
};
```

用法：

```cpp
Point p{3, 4};
p.move(2, -1);
cout << p.x << ", " << p.y;  // 输出 5, 3
```

> 在 C++ 里，struct 和 class 本质上几乎一样，
> 只是默认访问权限不同（struct 默认 public，class 默认 private）。

## 🧩 六、小结表格

| 名称     | 类型  | 作用             |
| ------ | --- | -------------- |
| struct | 关键字 | 定义结构体类型        |
| 不是函数   | ❌   | 它不是能执行的函数，而是一个 |
| 用途     | ✅   | 把多个变量组合成一个逻辑整体 |

🌟 **一句话总结：**

> struct 就像是你自己造的“数据盒子”，
> 把不同的信息（变量）装进一个名字里，让程序更有结构。

要不要我帮你写一个用 struct 排序学生成绩的小例子？

那样能让你看到结构体在算法题里是怎么真正发挥作用的。

对拍：

用超时的暴力解和优化后有bug的解进行对比检验

**核心思想**:

- 编写一个你**确信正确**的“暴力解法”（Brute-force Solution）。这个解法可以非常慢，但逻辑必须简单、清晰、易于实现，保证**正确性**（必须正确）。

- 编写一个**随机数据生成器**（Data Generator），用于产生大量的、各种情况的测试数据。

- 使用一个脚本，自动地重复以下过程：
1. 运行数据生成器，产生一组随机输入。

2. 用这组输入分别运行你的算法和“暴力解”程序。

3. 比较两个程序的输出结果。
- 如果两个程序的输出不一致，脚本就会停下来，并保留这组导致错误的测试数据。这样，你就可以利用这组“hack”数据来调试你的正解代码。

数据越小算法越暴力

## 什么是“构造题”（Constructive Problem）

在算法竞赛（比如 Codeforces、AtCoder、蓝桥杯等）里，

**构造题**是一类**不要求你计算某个值**，

而是要求你**自己设计出一个满足条件的解法或数据结构**的题。

简单说：

> 构造题不是“算出来”，而是“造出来”。

## 💬 一、什么是「交互题」（Interactive Problem）

通常用二分解决

在算法竞赛（比如 Codeforces、AtCoder、NOI 等）里，

**交互题**是一类“你和评测系统（出题人写的程序）进行对话”的题。

也就是说：

> 你不是一次性输入、一次性输出，
> 而是**多次与系统交互（问问题、得到反馈、再决定下一步）**。

## 🎮 二、和普通题的区别

| 类型  | 输入输出方式              | 举例                 |
| --- | ------------------- | ------------------ |
| 普通题 | 程序一开始就读完整输入，最后输出答案  | “输入数组，输出最大值”       |
| 交互题 | 你要多次读入 / 输出，与系统实时交流 | “系统藏了一个数，你通过提问去猜它” |

## 🧩 三、举个简单例子理解

假设有这样一道题 👇：

> 系统在 1~100 之间随机选了一个整数。
> 你可以多次输出一个数 x 来猜，系统会返回：
> 
> > 如果它比隐藏数小
> > < 如果它比隐藏数大
> > = 如果猜对了你要尽量少地猜中答案。

这就是典型的「交互题」——

你要写一个程序，通过“输出询问、读取反馈”来找到答案。

### 🧠 示例代码（伪代码）

```cpp
#include <iostream>
using namespace std;

int main() {
    int low = 1, high = 100;

    while (low <= high) {
        int mid = (low + high) / 2;
        cout << mid << endl;      // 向系统“提问”
        cout.flush();              // ⚠️ 一定要刷新输出（非常重要！）

        string response;
        cin >> response;           // 读入系统的反馈

        if (response == "=") break;
        else if (response == ">") low = mid + 1;
        else high = mid - 1;
    }

    return 0;
}
```

> 在评测时，评测系统会模拟“隐藏数”，并根据你的输出返回对应的反馈。

## ⚙️ 四、交互题的运行机制

你可以把它想象成一个“双人游戏”：

- **你**：编写程序（参赛者）

- **出题人**：编写一个“评测程序”（交互系统）

- 两者之间通过 **标准输入输出流（stdin/stdout）** 交流

流程大概是这样👇：

```
你输出问题（cout） ➜  系统读入问题并回答（cin）
系统输出反馈       ➜  你的程序读入反馈
```

⚠️ 注意：

如果你不 flush() 输出缓冲区（即不立即把输出发给系统），

系统可能就一直等不到你的“提问”，程序就会被卡死（超时）。

## 💥 五、为什么要出交互题？

交互题考察的是：

- 你能否通过**有限次查询获取信息**；

- 能否**用最少的操作**确定答案；

- 对**输入输出流同步**、**逻辑控制**的掌握。

常见考点：

| 类别     | 示例                        |
| ------ | ------------------------- |
| 二分查找交互 | 猜数字                       |
| 信息压缩   | 通过有限查询确定隐藏序列              |
| 博弈论    | 你与系统轮流操作                  |
| 智能策略   | 系统可能有“自适应”行为（会根据你之前的操作变化） |

## 📦 六、实际竞赛时注意事项

1. **每次输出后必须刷新**（cout.flush() 或 endl）；

2. **不要多输出、不少输出**；

3. **不要打印额外提示信息**（例如 “请输入数字：”）；

4. **严格按照交互格式**；

5. **在本地调试时**，可以用文件或模拟程序代替系统。

## 🧠 七、总结一句话

> **交互题 = 和评测系统“对话”的题。**
> 你要通过不断提问与反馈，逐步“探测出”隐藏的信息。

🎯 **关键词总结：**

| 概念          | 含义          |
| ----------- | ----------- |
| Interactive | 交互型题目       |
| flush()     | 刷新输出缓冲      |
| feedback    | 系统返回的反馈     |
| adaptive    | 反馈可能根据你行为变化 |
| strategy    | 设计最优询问策略    |
