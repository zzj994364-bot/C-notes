https://cses.fi/boi24/task/3221/

## **滑动窗口最小值（Sliding Window Minimum）**

你有一个包含 n 个整数的数组，你的任务是从左到右计算 **每个大小为 k 的窗口的最小值**。

本题输入数据规模很大，数组是通过生成器自动生成的。

------

### **输入**

第一行包含两个整数 **n** 和 **k**：

- n = 数组长度
- k = 窗口大小

第二行包含四个整数 **x, a, b, c**：生成器参数。

数组生成方式为：

- $x_1 = x$
- $x_i = (a x_{i-1} + b) \bmod c$ ，对于 $i = 2, 3, \dots, n$

------

### **输出**

输出所有窗口最小值的 **按位异或 XOR** 结果。

------

### **约束**

- $1 \le k \le n \le 10^7$
- $0 \le x, a, b \le 10^9$
- $1 \le c \le 10^9$

------

### **样例输入**

```
8 5
3 7 1 11
```

#### **生成的数组**

[3, 0, 1, 8, 2, 4, 7, 6]

#### **所有窗口最小值：**

- [3,0,1,8,2] → min = 0
- [0,1,8,2,4] → min = 0
- [1,8,2,4,7] → min = 1
- [8,2,4,7,6] → min = 2

最终答案：

0 ⊕ 0 ⊕ 1 ⊕ 2 = **3**











## 解题思路

使用**单调队列**维护滑动窗口的最大值或最小值



什么是单调队列？

给出一个窗口：[5, 1, 2, 4, 3]， 要求维护窗口的最小值
我们要做的是对窗口中五个元素进行单调递增排序

tip：他们的下标分别为0, 1, 2, 3, 4

1. 队首元素永远是当前窗口最小值
2. 新元素入队时，从队尾开始，**踢掉所有比它大的元素**
3. 队首元素如果不在窗口内了，就出队

得出这样一个[1, 2, 3]队列，我们剔除了对目的无贡献的元素(5， 4),保留了**有贡献(有机会成为最小值)**的元素

但**注意**，此时这个deque遍历输出出来是[1, 2, 4]，分表代表1， 2， 3的**下标**



## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <deque>
#include <algorithm>
using ll = long long;
using namespace std;

int main () {
    int n, k;
    cin >> n >> k;
    ll x, a, b, c;
    cin >> x >> a >> b >> c;

    vector<ll> v(n);
    v[0] = x;
    for (int i = 1; i < n; i++) v[i] = (v[i - 1] * a + b) % c;

    deque<int> dq; //使用dq储存单调队列的**下标**
                   //dq 中存的是下标，但整个 dq 始终保持 v[dq[i]] 单调递减（或递增）；
                   //换句话说，“单调性”作用在 值 上，而不是直接作用在下标上。

    ll res = 0;
    
    //使用i来判断窗口是否合法
    for (int i = 0; i < n; i++) {
        //保持单调
        while (!dq.empty() && v[dq.back()] > v[i]) { //此题是保持单调队列的递增
            dq.pop_back();
        }
        dq.push_back(i);

        //删除过期元素
        int left = i - k + 1;
        while (!dq.empty() && dq.front() < left) { 
            dq.pop_front();
        }

        //执行题目要求
        if (i >= k - 1) { //使用i来表达窗口合法的情况
            res ^= v[dq.front()];
        }
    }

    cout << res << endl;

    return 0;
}
```

