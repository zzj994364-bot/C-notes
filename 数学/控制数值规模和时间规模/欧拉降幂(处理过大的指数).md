# 欧拉降幂详细学习笔记

## 目录
1. [预备知识](#1-预备知识)
2. [欧拉函数](#2-欧拉函数)
3. [欧拉定理](#3-欧拉定理)
4. [扩展欧拉定理（欧拉降幂）](#4-扩展欧拉定理欧拉降幂)
5. [欧拉降幂公式](#5-欧拉降幂公式)
6. [代码实现](#6-代码实现)
7. [典型例题](#7-典型例题)
8. [实战技巧](#8-实战技巧)

---

## 1. 预备知识

### 1.1 问题引入

**问题**：如何计算 `a^b mod m`，当 b 特别大时（比如 b 有几千位）？

**示例**：
```
计算 2^(10^100) mod 7
计算 3^(999999999999999999) mod 10
```

即使使用快速幂，当 b 太大（如 b 是一个大数）时也无法直接计算。

**解决方案**：欧拉降幂！

### 1.2 互质的概念

**定义**：如果 gcd(a, b) = 1，则称 a 和 b 互质。

**示例**：
```
gcd(8, 15) = 1  → 8 和 15 互质
gcd(12, 18) = 6 → 12 和 18 不互质
```

---

## 2. 欧拉函数

### 2.1 定义

**欧拉函数 φ(n)**：小于等于 n 且与 n 互质的正整数个数。

**符号表示**：
```
φ(n) = |{x | 1 ≤ x ≤ n, gcd(x, n) = 1}|
```

### 2.2 示例计算

**示例 1**：φ(6)
```
检查 1 到 6 中与 6 互质的数：
- gcd(1, 6) = 1 ✓
- gcd(2, 6) = 2 ✗
- gcd(3, 6) = 3 ✗
- gcd(4, 6) = 2 ✗
- gcd(5, 6) = 1 ✓
- gcd(6, 6) = 6 ✗

所以 φ(6) = 2
```

**示例 2**：φ(10)
```
与 10 互质的数：1, 3, 7, 9
φ(10) = 4
```

**示例 3**：φ(7)（质数）
```
1, 2, 3, 4, 5, 6 都与 7 互质
φ(7) = 6
```

### 2.3 常见值

| n | φ(n) | 说明 |
|---|------|------|
| 1 | 1 | 特殊情况 |
| 2 | 1 | 质数 |
| 3 | 2 | 质数 |
| 4 | 2 | 1, 3 |
| 5 | 4 | 质数 |
| 6 | 2 | 1, 5 |
| 7 | 6 | 质数 |
| 8 | 4 | 1, 3, 5, 7 |
| 9 | 6 | 1, 2, 4, 5, 7, 8 |
| 10 | 4 | 1, 3, 7, 9 |

### 2.4 重要性质

**性质 1**：如果 p 是质数，则：
```
φ(p) = p - 1
```

**性质 2**：如果 p 是质数，k ≥ 1，则：
```
φ(p^k) = p^k - p^(k-1) = p^(k-1) × (p - 1)
```

**证明**：
```
p^k 的倍数有：p, 2p, 3p, ..., p^(k-1)×p，共 p^(k-1) 个
所以 φ(p^k) = p^k - p^(k-1)
```

**性质 3**（积性函数）：如果 gcd(m, n) = 1，则：
```
φ(m × n) = φ(m) × φ(n)
```

**性质 4**（通用公式）：如果 n 的质因数分解为：
```
n = p₁^k₁ × p₂^k₂ × ... × pₘ^kₘ
```
则：
```
φ(n) = n × (1 - 1/p₁) × (1 - 1/p₂) × ... × (1 - 1/pₘ)
```

### 2.5 计算欧拉函数

#### 方法 1：暴力枚举（小数据）

```cpp
int phi_brute(int n) {
    int result = 0;
    for (int i = 1; i <= n; i++) {
        if (gcd(i, n) == 1) result++;
    }
    return result;
}
```

**时间复杂度**：O(n log n)

#### 方法 2：质因数分解（推荐）

```cpp
int phi(int n) {
    int result = n;
    
    // 对每个质因子 p
    for (int p = 2; p * p <= n; p++) {
        if (n % p == 0) {
            // 除去所有 p 的倍数
            result = result / p * (p - 1);
            
            // 去除所有因子 p
            while (n % p == 0) {
                n /= p;
            }
        }
    }
    
    // 如果 n > 1，说明 n 还有一个大于 √n 的质因子
    if (n > 1) {
        result = result / n * (n - 1);
    }
    
    return result;
}
```

**时间复杂度**：O(√n)

**示例**：计算 φ(12)
```
12 = 2² × 3

φ(12) = 12 × (1 - 1/2) × (1 - 1/3)
      = 12 × 1/2 × 2/3
      = 4

验证：与 12 互质的数是 1, 5, 7, 11，共 4 个 ✓
```

#### 方法 3：线性筛（批量计算）

如果需要计算 1 到 n 的所有 φ 值：

```cpp
void phi_table(int n, vector<int>& phi) {
    phi.resize(n + 1);
    for (int i = 0; i <= n; i++) phi[i] = i;
    
    for (int i = 2; i <= n; i++) {
        if (phi[i] == i) {  // i 是质数
            for (int j = i; j <= n; j += i) {
                phi[j] = phi[j] / i * (i - 1);
            }
        }
    }
}
```

**时间复杂度**：O(n log log n)

---

## 3. 欧拉定理

### 3.1 定理陈述

**欧拉定理（Euler's Theorem）**：

如果 gcd(a, m) = 1（a 和 m 互质），则：
```
a^φ(m) ≡ 1 (mod m)
```

### 3.2 与费马小定理的关系

**费马小定理**是欧拉定理的特殊情况：

当 m = p（质数）时：
```
φ(p) = p - 1
所以 a^(p-1) ≡ 1 (mod p)
```

### 3.3 证明思路

**证明**（简化版）：

设与 m 互质的数为 `r₁, r₂, ..., r_φ(m)`

考虑集合 `S = {ar₁, ar₂, ..., ar_φ(m)}`

可以证明 S 模 m 后仍然是与 m 互质的 φ(m) 个数（重新排列）

因此：
```
(ar₁) × (ar₂) × ... × (ar_φ(m)) ≡ r₁ × r₂ × ... × r_φ(m) (mod m)
a^φ(m) × (r₁×r₂×...×r_φ(m)) ≡ r₁×r₂×...×r_φ(m) (mod m)
a^φ(m) ≡ 1 (mod m)
```

### 3.4 验证示例

**示例 1**：a=2, m=9
```
gcd(2, 9) = 1 ✓
φ(9) = 6

计算 2^6 mod 9：
2^6 = 64 = 7×9 + 1
所以 2^6 ≡ 1 (mod 9) ✓
```

**示例 2**：a=3, m=10
```
gcd(3, 10) = 1 ✓
φ(10) = 4

计算 3^4 mod 10：
3^4 = 81 = 8×10 + 1
所以 3^4 ≡ 1 (mod 10) ✓
```

### 3.5 应用：降幂

利用欧拉定理可以降低指数：

如果 gcd(a, m) = 1 且 b ≥ φ(m)：
```
a^b ≡ a^(b mod φ(m)) (mod m)
```

**证明**：
```
设 b = k×φ(m) + r（其中 r = b mod φ(m)）

a^b = a^(k×φ(m) + r)
    = (a^φ(m))^k × a^r
    ≡ 1^k × a^r
    ≡ a^r (mod m)
```

**示例**：计算 3^100 mod 10
```
gcd(3, 10) = 1 ✓
φ(10) = 4

3^100 ≡ 3^(100 mod 4) ≡ 3^0 ≡ 1 (mod 10)

验证：3^1=3, 3^2=9, 3^3=27≡7, 3^4=81≡1
      3^100 = (3^4)^25 ≡ 1^25 ≡ 1 ✓
```

---

## 4. 扩展欧拉定理（欧拉降幂）

### 4.1 问题

**欧拉定理的局限**：要求 gcd(a, m) = 1

但实际问题中，a 和 m 可能不互质！

**例如**：计算 `2^1000 mod 6`
- gcd(2, 6) = 2 ≠ 1
- 欧拉定理不适用！

### 4.2 扩展欧拉定理

**定理**：对于任意正整数 a, m 和 b，有：

```
a^b ≡ a^(b mod φ(m) + φ(m)) (mod m)  （当 b ≥ φ(m) 时）
```

**更精确的表述**：

```
         ⎧ a^b mod m,                    如果 b < φ(m)
a^b ≡   ⎨
         ⎩ a^(b mod φ(m) + φ(m)) mod m,  如果 b ≥ φ(m)
```

**注意**：
- 不需要 gcd(a, m) = 1
- 当 b ≥ φ(m) 时才能降幂
- 降幂后的指数是 `b mod φ(m) + φ(m)`，**不是** `b mod φ(m)`

### 4.3 为什么要加 φ(m)？

**原因**：保证正确性

**反例**（如果不加 φ(m)）：
```
计算 2^2 mod 6：
φ(6) = 2
如果用 2^(2 mod 2) = 2^0 = 1，错误！
实际：2^2 = 4 mod 6 = 4

正确做法：
因为 b=2 ≥ φ(m)=2，用扩展公式
2^2 ≡ 2^(2 mod 2 + 2) ≡ 2^2 ≡ 4 (mod 6) ✓
```

### 4.4 证明思路

完整证明较复杂，这里给出直观理解：

1. 当 gcd(a, m) = 1 时，退化为普通欧拉定理
2. 当 gcd(a, m) > 1 时，a^k 在某个时刻会进入循环
3. 循环长度是 φ(m) 的因子
4. 加上 φ(m) 确保进入循环区间

---

## 5. 欧拉降幂公式

### 5.1 完整公式

```
         ⎧ a^b mod m,                           如果 b < φ(m)
a^b ≡   ⎨
         ⎩ a^((b mod φ(m)) + φ(m)) mod m,       如果 b ≥ φ(m)
```

### 5.2 实际使用的简化版本

**在竞赛中常用的写法**：

当 b 很大（超过 log 级别）时，直接使用：
```
a^b ≡ a^(b mod φ(m) + φ(m)) (mod m)
```

**原因**：
- 如果 b 本身很大（如字符串形式），那么 b ≥ φ(m) 几乎必然成立
- φ(m) ≤ m，所以 b 只要大于 m 就肯定满足条件

### 5.3 判断 b ≥ φ(m) 的技巧

**方法 1**：直接比较
```cpp
if (b >= phi_m) {
    // 使用扩展公式
} else {
    // 直接计算
}
```

**方法 2**：读入时判断（b 是字符串）
```cpp
string b_str;
cin >> b_str;

bool b_large = false;
int b_mod_phi = 0;

// 边读入边取模
for (char c : b_str) {
    b_mod_phi = b_mod_phi * 10 + (c - '0');
    if (b_mod_phi >= phi_m) b_large = true;
    b_mod_phi %= phi_m;
}

int actual_exp = b_large ? (b_mod_phi + phi_m) : b_mod_phi;
```

### 5.4 详细示例

**示例 1**：计算 2^10 mod 6

```
步骤 1：计算 φ(6)
φ(6) = 2

步骤 2：判断 b 与 φ(m) 的关系
b = 10 ≥ φ(6) = 2 ✓

步骤 3：使用扩展欧拉定理
2^10 ≡ 2^(10 mod 2 + 2) ≡ 2^(0 + 2) ≡ 2^2 ≡ 4 (mod 6)

验证：2^10 = 1024 = 170×6 + 4 ✓
```

**示例 2**：计算 3^1000 mod 10

```
步骤 1：计算 φ(10)
φ(10) = 4

步骤 2：判断
b = 1000 ≥ φ(10) = 4 ✓

步骤 3：计算
3^1000 ≡ 3^(1000 mod 4 + 4) ≡ 3^(0 + 4) ≡ 3^4 (mod 10)

3^4 = 81 ≡ 1 (mod 10)

所以 3^1000 ≡ 1 (mod 10)
```

**示例 3**：计算 2^123456789 mod 100

```
步骤 1：计算 φ(100)
100 = 4 × 25 = 2² × 5²
φ(100) = φ(2²) × φ(5²) = 2 × 20 = 40

步骤 2：判断
b = 123456789 ≥ 40 ✓

步骤 3：计算
2^123456789 ≡ 2^(123456789 mod 40 + 40)
            ≡ 2^(9 + 40)
            ≡ 2^49 (mod 100)

步骤 4：用快速幂计算 2^49 mod 100
2^49 mod 100 = 24
```

---

## 6. 代码实现

### 6.1 完整实现

```cpp
#include <iostream>
#include <string>
using namespace std;

// 计算欧拉函数
long long phi(long long n) {
    long long result = n;
    for (long long p = 2; p * p <= n; p++) {
        if (n % p == 0) {
            result = result / p * (p - 1);
            while (n % p == 0) n /= p;
        }
    }
    if (n > 1) result = result / n * (n - 1);
    return result;
}

// 快速幂
long long power_mod(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1) result = result * base % mod;
        base = base * base % mod;
        exp >>= 1;
    }
    return result;
}

// 欧拉降幂：计算 a^b mod m（b 以字符串形式给出）
long long euler_reduce(long long a, string b_str, long long m) {
    if (m == 1) return 0;
    
    // 计算 φ(m)
    long long phi_m = phi(m);
    
    // 判断 b 是否 ≥ φ(m)，同时计算 b mod φ(m)
    bool b_large = false;
    long long b_mod_phi = 0;
    
    for (char c : b_str) {
        b_mod_phi = b_mod_phi * 10 + (c - '0');
        if (b_mod_phi >= phi_m) b_large = true;
        b_mod_phi %= phi_m;
    }
    
    // 确定实际指数
    long long actual_exp = b_large ? (b_mod_phi + phi_m) : b_mod_phi;
    
    // 快速幂计算结果
    return power_mod(a, actual_exp, m);
}

int main() {
    long long a, m;
    string b;
    
    cin >> a >> b >> m;
    
    cout << euler_reduce(a, b, m) << endl;
    
    return 0;
}
```

### 6.2 简化版本（假设 b 一定很大）

当题目保证 b 很大时，可以简化：

```cpp
long long euler_reduce_simple(long long a, string b_str, long long m) {
    if (m == 1) return 0;
    
    long long phi_m = phi(m);
    long long b_mod_phi = 0;
    
    // 直接计算 b mod φ(m)
    for (char c : b_str) {
        b_mod_phi = (b_mod_phi * 10 + (c - '0')) % phi_m;
    }
    
    // 直接使用 b mod φ(m) + φ(m)
    return power_mod(a, b_mod_phi + phi_m, m);
}
```

### 6.3 处理多组数据

```cpp
int main() {
    int T;
    cin >> T;
    
    while (T--) {
        long long a, m;
        string b;
        cin >> a >> b >> m;
        
        cout << euler_reduce(a, b, m) << endl;
    }
    
    return 0;
}
```

---

## 7. 典型例题

### 7.1 基础题：直接应用

**题目**：给定 a, b, m，计算 a^b mod m。  
其中 a, m ≤ 10^9，b 是一个不超过 10^6 位的十进制数。

**解法**：直接用欧拉降幂

```cpp
long long solve(long long a, string b, long long m) {
    return euler_reduce(a, b, m);
}
```

**示例**：
```
输入：2 10000000000 1000000007
输出：49 （即 2^(10^10) mod 10^9+7）
```

### 7.2 进阶题：幂塔

**题目**：计算 a^(a^(a^(...))) mod m （有 n 层）

**思路**：从上到下递归降幂

```cpp
long long power_tower(long long a, int n, long long m) {
    if (m == 1) return 0;
    if (n == 0) return 1;
    if (n == 1) return a % m;
    
    long long phi_m = phi(m);
    
    // 递归计算上一层
    long long exp = power_tower(a, n - 1, phi_m);
    
    // 应用欧拉降幂
    return power_mod(a, exp + phi_m, m);
}
```

**示例**：计算 3^(3^3) mod 100
```
3^(3^3) = 3^27

φ(100) = 40
27 ≥ 40? 否

所以直接计算：3^27 mod 100

实际上我们需要递归：
第1层：3^27 mod 100
  需要知道 27 mod φ(100) = 27 mod 40 = 27
  因为 27 < 40，直接用 27

3^27 mod 100 = 87
```

### 7.3 复杂题：组合应用

**题目**：计算 Σ(i^i) mod m，其中 i 从 1 到 n，n ≤ 10^6

**解法**：对每个 i^i 使用欧拉降幂

```cpp
long long solve(long long n, long long m) {
    long long result = 0;
    long long phi_m = phi(m);
    
    for (long long i = 1; i <= n; i++) {
        // 计算 i^i mod m
        long long exp = (i >= phi_m) ? (i % phi_m + phi_m) : i;
        result = (result + power_mod(i, exp, m)) % m;
    }
    
    return result;
}
```

---

## 8. 实战技巧

### 8.1 字符串读入大数

**技巧**：边读入边取模

```cpp
long long read_mod(string s, long long mod) {
    long long result = 0;
    for (char c : s) {
        result = (result * 10 + (c - '0')) % mod;
    }
    return result;
}
```

### 8.2 判断 b ≥ φ(m)

**方法 1**：字符串长度判断
```cpp
bool is_large(string b_str, long long phi_m) {
    // 如果位数过多，肯定大
    if (b_str.length() > 10) return true;
    
    // 否则转换比较
    long long b = 0;
    for (char c : b_str) {
        b = b * 10 + (c - '0');
        if (b >= phi_m) return true;
    }
    return false;
}
```

**方法 2**：边读边判断（推荐）
```cpp
// 在 euler_reduce 函数中已实现
```

### 8.3 特殊情况处理

```cpp
// m = 1 的情况
if (m == 1) return 0;

// a = 0 的情况
if (a == 0) return 0;

// a = 1 的情况
if (a == 1) return 1;

// b = 0 的情况（字符串为"0"）
if (b_str == "0") return 1;
```

### 8.4 优化：预处理欧拉函数

如果需要多次查询同一个模数：

```cpp
// 预处理 1 到 n 的欧拉函数
vector<long long> phi_table(n + 1);
for (int i = 0; i <= n; i++) phi_table[i] = i;

for (int i = 2; i <= n; i++) {
    if (phi_table[i] == i) {  // i 是质数
        for (int j = i; j <= n; j += i) {
            phi_table[j] = phi_table[j] / i * (i - 1);
        }
    }
}
```

### 8.5 常见模数的 φ 值

**记住这些常用值**：

| m | φ(m) | 说明 |
|---|------|------|
| 10^9+7 | 10^9+6 | 常见质数模 |
| 998244353 | 998244352 | 常见质数模 |
| 10 | 4 | φ(2×5) |
| 100 | 40 | φ(4×25) |
| 1000 | 400 | φ(8×125) |
| 2^k | 2^(k-1) | 2 的幂次 |

### 8.6 调试技巧

**验证小数据**：
```cpp
// 对于小的 b，暴力验证
long long brute_force(long long a, long long b, long long m) {
    long long result = 1;
    for (long long i = 0; i < b; i++) {
        result = result * a % m;
    }
    return result;
}

// 测试
assert(euler_reduce(a, to_string(b), m) == brute_force(a, b, m));
```

---

## 9. 总结

### 9.1 核心公式

```
欧拉定理：
a^φ(m) ≡ 1 (mod m)  （gcd(a,m)=1）

扩展欧拉定理（欧拉降幂）：
a^b ≡ a^(b mod φ(m) + φ(m)) (mod m)  （b ≥ φ(m)）
```

### 9.2 使用场景

1. **指数特别大**（如字符串形式）
2. **幂塔问题**（a^(a^(a^...))）
3. **不满足互质条件**
4. **需要降低指数复杂度**

### 9.3 注意事项

⚠️ **关键点**：
1. 降幂后是 `b mod φ(m) + φ(m)`，不要忘记加 φ(m)
2. 必须判断 b ≥ φ(m)
3. 特判 m=1 的情况
4. 字符串读入时注意溢出

### 9.4 模板代码

```cpp
// 最终模板
long long euler_theorem(long long a, string b, long long m) {
    if (m == 1) return 0;
    
    long long phi_m = phi(m);
    bool large = false;
    long long b_mod = 0;
    
    for (char c : b) {
        b_mod = b_mod * 10 + (c - '0');
        if (b_mod >= phi_m) large = true;
        b_mod %= phi_m;
    }
    
    long long exp = large ? (b_mod + phi_m) : b_mod;
    return power_mod(a, exp, m);
}
```

