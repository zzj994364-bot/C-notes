https://leetcode.com/problems/increasing-triplet-subsequence/



## 递增的三元子序列

 **难度**：中等

**题目描述**：
 给你一个整数数组 `nums`，如果存在一组三个索引 `(i, j, k)` 满足 `i < j < k` 且 `nums[i] < nums[j] < nums[k]`，返回 `true`。如果不存在这样的索引组合，返回 `false`。

**示例**：

**示例 1**：
 输入：`nums = [1,2,3,4,5]`
 输出：`true`
 解释：任何满足 `i < j < k` 的三元组都是有效的。

**示例 2**：
 输入：`nums = [5,4,3,2,1]`
 输出：`false`
 解释：不存在符合条件的三元组。

**示例 3**：
 输入：`nums = [2,1,5,0,4,6]`
 输出：`true`
 解释：一个有效的三元组是 `(3, 4, 5)`，因为 `nums[3] == 0 < nums[4] == 4 < nums[5] == 6`。

**约束条件**：

- `1 <= nums.length <= 5 * 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`
- 时间复杂度：O(n)







## 解题思路

需要维护两个变量 `first` 和 `second`：

- `first`：目前找到的最小值
- `second`：比 `first` 大的最小值

遍历数组：

1. 如果当前元素 `x` <= `first`，更新 `first = x`
2. 否则如果 `x` <= `second`，更新 `second = x`
3. 否则，说明找到了 `first < second < x`，返回 `true`



## 代码实现

```cpp
#include <iostream>
#include <vector>
using ll = long long;
using namespace std;

int main () {
    vector<ll> a;
    ll x;
    while (cin >> x) {
        a.push_back(x);
    }

    //初始化为最大值这一步很关键，避免了如何将second初始化的复杂逻辑
    ll first = LLONG_MAX;
    ll second = LLONG_MAX;
    for (auto y : a) {
        if (y <= first) first = y; //维护first
        else if (y <= second) second = y; //维护second
        else {
            cout << "true" << endl;
            return 0;
        }
    }

    cout << "false" << endl;

    return 0;
}
```

