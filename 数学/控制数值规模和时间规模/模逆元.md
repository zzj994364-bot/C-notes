# 模逆元

模逆元主要用来处理模运算中的**除法运算**

费马小定理（Fermat's Little Theorem）和扩展欧几里得算法 (Extended Euclidean Algorithm)都能用于求解逆模元，其中后者的实用范围更广。

## 费马小定理基础

费马小定理（Fermat's Little Theorem）是数论中一个非常重要的定理，它在模运算，特别是求解模逆元方面，有着核心的应用。

**定理**: 如果 `p` 是一个**质数**，并且整数 `a` 不是 `p` 的倍数（即 `a % p != 0`），那么有 $a^{p-1} \equiv 1 \pmod p$

**核心应用与解决的问题**:

1.  **求解模逆元 (Finding Modular Inverses)**: 这是费马小定理在算法竞赛中最主要的应用。

      * 模 `p` 乘法逆元的定义是：对于整数 `a`，存在一个整数 `x` 使得 $a \cdot x \equiv 1 \pmod p$。`x` 就是 `a` 的模 `p` 逆元。
      * 根据费马小定理 $a^{p-1} \equiv 1 \pmod p$，我们可以将其改写为 $a \cdot a^{p-2} \equiv 1 \pmod p$。
      * 通过对比，可以得出 `a` 的模 `p` 逆元就是 **$a^{p-2} \pmod p$**。
      * **前提条件**: 这个方法**仅适用于模数 `p` 是质数**的情况。

2.  **简化模幂运算 (Simplifying Modular Exponentiation)**:

      * 在模 `p` 的意义下，指数可以对 `p-1` 取模。即 $a^k \equiv a^{k \pmod{p-1}} \pmod p$。这在处理指数非常大的情况时很有用。

时间/空间复杂度：

  * **时间复杂度**: $O(\log p)$。使用费马小定理求逆元，核心是计算 $a^{p-2} \pmod p$，这需要借助快速幂算法，其时间复杂度为对数级别。
  * **空间复杂度**: $O(1)$（对于迭代实现的快速幂）。

## 算法的流程

使用费马小定理计算 `a` 关于质数模 `p` 的乘法逆元的流程如下：

1.  **确认前提**: 保证模数 `p` 是一个质数，且 `a` 不是 `p` 的倍数。在通常的算法题目中，模数（如 $10^9 + 7$）通常都是给定的质数。
2.  **确定指数**: 根据定理，逆元等于 `a` 的 `p-2` 次幂。
3.  **计算模幂**: 调用快速幂算法（Binary Exponentiation）来计算 $a^{p-2} \pmod p$ 的值。
4.  **返回结果**: 快速幂的计算结果即为所求的 `a` 的模 `p` 乘法逆元。

## 算法模板

该模板展示了如何利用费马小定理和快速幂来求解模逆元。为了模板的完整性，这里一并提供了快速幂函数。

```cpp
/**
 * @brief 快速幂取模，计算 (base^exp) % mod
 * 这是计算模逆元的基础
 * @param base 底数
 * @param exp 指数
 * @param mod 模数
 * @return (base^exp) % mod 的结果
 */
long long power_mod(long long base, long long exp, long long mod) {
    long long res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1) res = (res * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return res;
}

/**
 * @brief 使用费马小定理计算 n 关于质数 p 的乘法逆元
 *
 * 前提条件：p 是一个质数，且 n 不为 p 的倍数。
 * 如果 n 为 p 的倍数，则逆元不存在。
 *
 * @param n 要求逆元的数
 * @param p 质数模数
 * @return n 的模 p 乘法逆元。如果 n 是 p 的倍数，返回 0 (或其他错误标识)
 */
long long mod_inverse_fermat(long long n, long long p) {
    // 确保 n 在 [0, p-1] 范围内
    n %= p;
    if (n == 0) {
        // 0 没有模 p 的乘法逆元
        return 0; 
    }
    
    // 根据费马小定理，n 的模 p 逆元是 n^(p-2) % p
    return power_mod(n, p - 2, p);
}
```

## 扩展欧几里得算法基础

扩展欧几里得算法是欧几里得算法（用于求 $\gcd(a, b)$）的延伸。它不仅能计算出两个整数 $a$ 和 $b$ 的最大公约数 $g$，还能同时找出两个整数 $x$ 和 $y$，使得它们满足**贝祖定理（Bézout's identity）**：

$ax + by = \gcd(a, b)$

这个 $x$ 和 $y$（可以为负或零）是解决许多数论问题的关键。

**解决的问题与应用**:

1.  **求解线性不定方程 (Linear Diophantine Equation)**:

      * 求解形如 $ax + by = c$ 的整数解。
      * **有解的充要条件**: $c$ 必须是 $\gcd(a, b)$ 的倍数。
      * **求解**: 先用扩展欧几里得算法求出 $ax_0 + by_0 = \gcd(a, b)$ 的一组解 $(x_0, y_0)$。如果 $c \% \gcd(a, b) \neq 0$，则无解。否则，令 $g = \gcd(a, b)$，则方程的一组特解为 $x = x_0 \cdot (c/g)$， $y = y_0 \cdot (c/g)$。

2.  **求解模线性方程 (Solving Modular Linear Equations)**:

      * 求解 $ax \equiv c \pmod m$。
      * 这等价于求解线性不定方程 $ax + my = c$，其中 $y$ 是一个辅助整数。

3.  **求解模逆元 (Modular Multiplicative Inverse)**:

      * 这是该算法**最核心和最常见**的应用。
      * 求解 $a$ 关于模 $m$ 的逆元 $x$，即求解 $ax \equiv 1 \pmod m$。
      * 这等价于求解 $ax + my = 1$。
      * **有解的充要条件**: $\gcd(a, m) = 1$。
      * 当 $\gcd(a, m) = 1$ 时，扩展欧几里得算法会返回 $ax + my = 1$，此时的 $x$ 就是 $a$ 的一个模 $m$ 逆元。最终结果需要调整到 $[1, m-1]$ 范围内（通过 $(x \% m + m) \% m$）。

时间/空间复杂度：

  * **时间复杂度**: $O(\log(\min(a, b)))$。与欧几里得算法相同。
  * **空间复杂度**: $O(\log(\min(a, b)))$。主要来自递归调用栈的深度。

## 算法的流程

算法基于 $\gcd(a, b) = \gcd(b, a \% b)$ 这一性质，通过递归进行。

1.  **目标**: 求解 $ax + by = \gcd(a, b)$。
2.  **基准情况 (Base Case)**:
      * 当 $b = 0$ 时， $\gcd(a, 0) = a$。
      * 此时方程变为 $ax + 0y = a$。
      * 显然，一组特解为 $x = 1, y = 0$。
3.  **递归步骤 (Recursive Step)**:
      * 假设我们已经递归地求出了子问题 $bx' + (a \% b)y' = \gcd(b, a \% b)$ 的一组解 $(x', y')$。
      * 我们的目标是利用 $(x', y')$ 来推导出 $ax + by = \gcd(a, b)$ 的解 $(x, y)$。
      * 我们知道 $\gcd(a, b) = \gcd(b, a \% b)$。
      * 将 $a \% b$ 替换为 $a - \lfloor a/b \rfloor \cdot b$：
        $bx' + (a - \lfloor a/b \rfloor \cdot b)y' = \gcd(a, b)$
      * 展开并重新整理，使其变为 $ax + by$ 的形式：
        $bx' + ay' - \lfloor a/b \rfloor \cdot b \cdot y' = \gcd(a, b)$
        $ay' + b(x' - \lfloor a/b \rfloor \cdot y') = \gcd(a, b)$
      * 对比 $ax + by = \gcd(a, b)$，我们可以得出：
          * $x = y'$
          * $y = x' - (a / b) \cdot y'$  (C++ 中整数除法自动取整)
      * 因此，我们通过递归调用得到 $x', y'$，然后用上述公式反推出 $x, y$ 即可。

## 算法模板代码

```cpp
#include <iostream>

/**
 * @brief 扩展欧几里得算法 (Recursive)
 * 求解 ax + by = gcd(a, b)
 * @param a 方程的第一个系数
 * @param b 方程的第二个系数
 * @param x (输出参数) 方程解 x 的引用
 * @param y (输出参数) 方程解 y 的引用
 * @return a 和 b 的最大公约数 gcd(a, b)
 */
long long extended_gcd(long long a, long long b, long long& x, long long& y) {
    // 1. 基准情况
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    
    // 2. 递归步骤
    long long x1, y1; // 存储子问题的解 x', y'
    long long g = extended_gcd(b, a % b, x1, y1);
    
    // 3. 利用 x', y' 推导 x, y
    // x = y'
    // y = x' - (a/b) * y'
    x = y1;
    y = x1 - (a / b) * y1;
    
    return g;
}

/**
 * @brief 求解 a 关于模 m 的乘法逆元
 * @param a 待求逆元的数
 * @param m 模数
 * @return a 的模 m 乘法逆元。如果逆元不存在，返回 -1 (或抛出异常)
 */
long long mod_inverse(long long a, long long m) {
    long long x, y;
    long long g = extended_gcd(a, m, x, y);
    
    if (g != 1) {
        // 逆元不存在
        return -1;
    } else {
        // 确保 x 在 [0, m-1] 范围内
        return (x % m + m) % m;
    }
}
```