# 容器中压入空容器：{}

✅ 基本概念

在 C++ 中，当一个容器（如 vector、stack、queue 等）要存储另一个容器（如 vector<int>、set<char> 等）时，可以使用 {} 来表示一个**空的内部容器**。

✅ 示例写法

```cpp
stack<vector<int>> stk;
stk.push({});  // 压入一个空的 vector<int>

vector<set<char>> v;
v.push_back({});  // 添加一个空的 set<char>
```

这些写法等价于：

```cpp
stk.push(vector<int>());
v.push_back(set<char>());
```

# 关于查找元素和查重

### 可以用 .find() 和 .count() 的容器

| 容器               | 说明         |
| ------------------ | ------------ |
| map                | find(key)    |
| multimap           | find(key)    |
| set                | find(key)    |
| multiset           | find(key)    |
| unordered_map      | 哈希表实现， |
| unordered_multimap | 哈希表实现， |
| unordered_set      | 哈希表实现， |
| unordered_multiset | 哈希表实现， |

### 不能用 .find() 和 .count() 的容器

| 容器           | 原因                                |
| -------------- | ----------------------------------- |
| vector         | 不是关联容器，没有 key 索引，只能用 |
| deque          | 同 vector，顺序容器，没有 key       |
| list           | 双向链表，没有 key                  |
| stack          | 不提供迭代器和查找接口              |
| queue          | 不提供迭代器和查找接口              |
| priority_queue | 不提供迭代器和查找接口              |

⚠️ 说明：

- .find() / .count() **只在关联容器**（map/set/multimap/multiset）或 **哈希容器**（unordered_*）中可用

- **顺序容器**（vector/deque/list）只能用算法库函数 std::find 或手动遍历

  

### 顺序容器查找示例（vector）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> v = {1,2,3,4};

    if (find(v.begin(), v.end(), 3) != v.end()) {
        cout << "3 exists" << endl;
    }

    cout << count(v.begin(), v.end(), 2) << endl; // 输出出现次数
}
```