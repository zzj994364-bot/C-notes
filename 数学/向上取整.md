# 向上取整技巧笔记：`((n + k - 1) / k) * k`

## 1. 问题背景

### 常见需求

在编程中，我们经常需要找到**大于等于 n 的最小的 k 的倍数**。

**例子**：

- n = 23, k = 7 → 找到 28（因为 7, 14, 21, **28**, 35...）
- n = 100, k = 7 → 找到 105（因为 98, **105**, 112...）
- n = 21, k = 7 → 找到 21（本身就是倍数）

### 应用场景

- 内存对齐（align）
- 分页计算
- 资源分配（分组问题）
- 向上取整除法
- 构造算法题目

------

## 2. 核心公式

cpp

```cpp
long long result = ((n + k - 1) / k) * k;
```

这个公式做了两件事：

1. `(n + k - 1) / k` → 计算 ⌈n/k⌉（向上取整）
2. `× k` → 乘回去得到 k 的倍数

------

## 3. 为什么这样做？

### 问题：整数除法是向下取整的

在 C++ 中：



```cpp
7 / 3 = 2      // 实际是 2.333...，向下取整
10 / 3 = 3     // 实际是 3.333...，向下取整
9 / 3 = 3      // 正好整除
```

但我们需要**向上取整**：
```
⌈7/3⌉ = 3
⌈10/3⌉ = 4
⌈9/3⌉ = 3
```

### 核心技巧：加 (k-1) 再除以 k
```
⌈n/k⌉ = ⌊(n + k - 1) / k⌋
```

**为什么加 k-1？**

- 如果 n 是 k 的倍数，加 (k-1) 不会跨越到下一个倍数
- 如果 n 不是 k 的倍数，加 (k-1) 刚好跨越到下一个倍数

---

## 4. 图示理解

### 数轴可视化
```
k 的倍数分布：
0────k────2k────3k────4k────5k────6k
          │         │  ↑
          │         │  n=23 (不是倍数)
          │         └─→ 需要找到 4k=28
          │
          └─ 如果 n=2k=14，答案就是 2k
```

### 分组理解（装箱问题）

假设你有 n 个苹果，每个箱子装 k 个：
```
n = 23 个苹果，k = 7 个/箱

箱子1: ●●●●●●● (7个)
箱子2: ●●●●●●● (7个)
箱子3: ●●●●●●● (7个)
箱子4: ●●       (2个) ← 没装满但也要一个箱子

需要 4 个箱子 → 总容量 = 4 × 7 = 28
```

**公式计算**：
```
箱子数 = ⌈23/7⌉ = (23 + 6) / 7 = 29 / 7 = 4
总容量 = 4 × 7 = 28
```

---

## 5. 数学证明

设 `n = q × k + r`，其中 `0 ≤ r < k`（除法定理）

### 情况1：r = 0（n 是 k 的倍数）
```
n = q × k
⌈n/k⌉ = q

(n + k - 1) / k = (q×k + k - 1) / k
                = q + (k - 1) / k

因为 0 < k-1 < k，所以 (k-1)/k = 0（整数除法）

结果 = q ✓
最终 = q × k = n ✓
```

### 情况2：r > 0（n 不是 k 的倍数）
```
n = q × k + r，其中 1 ≤ r < k
⌈n/k⌉ = q + 1

(n + k - 1) / k = (q×k + r + k - 1) / k
                = q + (r + k - 1) / k

因为 1 ≤ r < k，所以：
k ≤ r + k - 1 ≤ 2k - 2 < 2k

因此 (r + k - 1) / k = 1

结果 = q + 1 ✓
最终 = (q + 1) × k ✓
```

---

## 6. 具体例子

### 例1：n 不是 k 的倍数
```
n = 23, k = 7

步骤1：计算需要多少个 k
⌈23/7⌉ = (23 + 7 - 1) / 7 = 29 / 7 = 4

步骤2：乘以 k 得到倍数
4 × 7 = 28 ✓

验证：7×3=21 < 23 < 7×4=28
```

### 例2：n 是 k 的倍数
```
n = 21, k = 7

步骤1：
⌈21/7⌉ = (21 + 7 - 1) / 7 = 27 / 7 = 3

步骤2：
3 × 7 = 21 ✓

验证：21 本身就是 7 的倍数
```

### 例3：n < k
```
n = 5, k = 7

步骤1：
⌈5/7⌉ = (5 + 7 - 1) / 7 = 11 / 7 = 1

步骤2：
1 × 7 = 7 ✓

验证：0 < 5 < 7
```

### 例4：n = k
```
n = 7, k = 7

步骤1：
⌈7/7⌉ = (7 + 7 - 1) / 7 = 13 / 7 = 1

步骤2：
1 × 7 = 7 ✓

验证：7 本身就是倍数
```

### 例5：大数
```
n = 1000000007, k = 999999

步骤1：
(1000000007 + 999999 - 1) / 999999
= 1001000005 / 999999
= 1001

步骤2：
1001 × 999999 = 1000998999 ✓
```

---

## 7. 为什么是 k-1 而不是 k？

### 如果加 k 会怎样？

**反例**：n = 21, k = 7
```
错误公式：(n + k) / k × k

(21 + 7) / 7 × 7 = 28 / 7 × 7 = 4 × 7 = 28

但正确答案是 21！❌
```

**原因**：
- 当 n 恰好是 k 的倍数时，加 k 会"推过头"
- 加 k-1 是"安全的上界"，既能推动不是倍数的情况，又不会推过已经是倍数的情况

### 直观理解
```
k-1 是"最大的安全余数"

余数范围：0 ≤ r < k

- 如果 r = 0（没有余数）
  0 + (k-1) < k，不会进位

- 如果 r > 0（有余数）
  r + (k-1) ≥ k，必定进位
```

------

## 8. 常见变体

### 变体1：单纯的向上取整除法

**只要商，不要倍数**：

cpp

```cpp
long long ceil_div = (n + k - 1) / k;
```

**用途**：

- 计算需要多少页
- 计算需要多少轮次
- 分组数量

**例子**：

cpp

```cpp
// 10 个人，每 3 人一组，需要几组？
int groups = (10 + 3 - 1) / 3;  // 4 组
```

### 变体2：向下取整到 k 的倍数

**找 ≤ n 的最大 k 的倍数**：

cpp

```cpp
long long floor_multiple = (n / k) * k;
```

**例子**：

cpp

```cpp
n = 23, k = 7
结果 = (23 / 7) * 7 = 3 * 7 = 21
```

### 变体3：向上取整到 2 的幂次

**找 ≥ n 的最小 2 的幂次**：

cpp

```cpp
// 方法1：位运算
long long next_power_of_2(long long n) {
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    n |= n >> 32;
    return n + 1;
}

// 方法2：循环
long long result = 1;
while (result < n) result *= 2;
```

### 变体4：内存对齐

**对齐到 k 字节边界**：

cpp

```cpp
long long aligned_address = ((address + alignment - 1) / alignment) * alignment;

// 或者用位运算（当 alignment 是 2 的幂次时）
long long aligned_address = (address + alignment - 1) & ~(alignment - 1);
```