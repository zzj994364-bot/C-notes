https://codeforces.com/contest/802/problem/J

## 把傻瓜继续往前送！（简单版）
 **每个测试的时间限制：** 1 秒
 **内存限制：** 256 MB

海蒂的朋友珍妮让海蒂帮忙把一封重要的信送给她们的一位共同好友。由于珍妮是爱尔兰人，海蒂怀疑这可能是个恶作剧。更具体地说，她怀疑信的内容是：“把这个傻瓜继续往前送！”，而收信的人在读完后，会让海蒂把同样的信再送给另一位与海蒂有共同交集的朋友，如此反复。

海蒂认为她的朋友们不想造成尴尬的局面，因此她不会被要求去拜访同一个人两次（包括珍妮本人）。她也知道任意两个彼此认识的朋友之间的旅行费用。她想知道：如果这真的是一个恶作剧，她最多会在路费上浪费多少钱？

海蒂有 $n$ 个朋友，编号为 $0$ 到 $n-1$，他们的关系网络构成一棵树。换句话说，任意两个朋友 $a, b$ 都彼此连通（可能是间接的，即存在一条从 $a$ 到 $b$ 的朋友序列，使得序列中任意相邻的两个人彼此直接认识），并且恰好有 $n-1$ 对朋友是直接认识的。

珍妮的编号是 0。

------

### 输入

第一行包含一个整数 $n$（$3 \le n \le 100$），表示朋友的数量。
 接下来的 $n-1$ 行中，每行包含三个用空格分隔的整数 $u, v, c$（$0 \le u, v \le n-1,\ 1 \le c \le 10^4$），表示 $u$ 和 $v$ 是直接认识的朋友，在他们之间旅行的花费为 $c$。

保证输入中的社交网络是一棵树。

------

### 输出

输出一个整数——最大的费用总和。

------

### 示例

**输入**

```
4
0 1 4
0 2 2
2 3 3
```

**输出**

```
5
```

**输入**

```
6
1 2 3
0 2 100
1 4 2
0 3 7
3 5 10
```

**输出**

```
105
```

**输入**

```
11
1 0 1664
2 0 881
3 2 4670
4 2 1555
5 1 1870
6 2 1265
7 2 288
8 7 2266
9 2 1536
10 6 3378
```

**输出**

```
5551
```

------

### 说明

在第二个示例中，最糟糕的情况如下：
 珍妮先让海蒂去编号为 2 的朋友那里（花费 100），
 然后 2 号朋友让她去 1 号朋友那里（花费 3），
 最后 1 号朋友让她去 4 号朋友那里（再花费 2）。













## 解题思路

构造一个**tree**

找到**以根节点0为中心，向各个子树方向延伸的最大代价路径**。

本质求**路径代价和**

```
    0
   / \
 (100)(7)
  2    3
  |    |
 (3) (10)
  1    5
  |
 (2)
  4
  
  最大代价：105
```

## 代码实现

```cpp
//0 based
//构造tree
//记录cost，输出max_cost
//按边dfs
#include <iostream>
#include <vector>
using namespace std;

struct edge {
    int to;
    int cost;
};

//adj list
vector<vector<edge>> adj;
vector<bool> visited;
int current_max = 0;

//一个求cost的dfs
void dfs(int u, int cost) {
    visited[u] = true;
    current_max = max(current_max, cost);
    //recursive case
    for (auto e : adj[u]) {
        if (!visited[e.to]) {
            dfs(e.to, cost + e.cost);
        }
    }
}

int main() {
    int n;
    cin >> n;

    //initialize adj and visited
    adj.resize(n + 1);
    visited.resize(n + 1, false);
    for (int i = 0; i < n - 1; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        adj[a].push_back({b, c});
        adj[b].push_back({a, c});
    }

    visited[0] = true; //标记根节点为 “以访问”
    int global_max = 0;
    //处理各个子树
    for (auto e : adj[0]) {
        current_max = 0;
        dfs(e.to, e.cost);

        global_max = max(global_max, current_max);
    }

    cout << global_max << endl;


    return 0;
}
```

