# 自定义排序

## 目录
- [基础概念](#基础概念)
- [sort() 函数详解](#sort-函数详解)
- [自定义排序的三种方式](#自定义排序的三种方式)
- [常见排序场景](#常见排序场景)
- [stable_sort() 稳定排序](#stable_sort-稳定排序)
- [partial_sort() 部分排序](#partial_sort-部分排序)
- [其他排序算法](#其他排序算法)
- [性能优化建议](#性能优化建议)
- [常见陷阱和注意事项](#常见陷阱和注意事项)
- [实战示例](#实战示例)

---

## 基础概念

### 什么是自定义排序?
自定义排序是指根据特定的比较规则对容器中的元素进行排序,而不是使用默认的 `<` 运算符。

### 常用排序函数
```cpp
R#include <algorithm>  // 所有排序函数都在这个头文件中

// 基本排序函数
std::sort()           // 快速排序(不稳定)
std::stable_sort()    // 稳定排序(归并排序)
std::partial_sort()   // 部分排序
std::nth_element()    // 第n个元素排序
```

---

## sort() 函数详解

### 函数原型
```cpp
// 版本1: 使用默认比较器(升序)
template<class RandomIt>
void sort(RandomIt first, RandomIt last);

// 版本2: 使用自定义比较器
template<class RandomIt, class Compare>
void sort(RandomIt first, RandomIt last, Compare comp);
```

### 基本用法
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr = {5, 2, 8, 1, 9};
    
    // 升序排序(默认)
    sort(arr.begin(), arr.end());
    // 结果: 1, 2, 5, 8, 9
    
    // 降序排序
    sort(arr.begin(), arr.end(), greater<int>());
    // 结果: 9, 8, 5, 2, 1
    
    return 0;
}
```

---

## 自定义排序的三种方式

### 1. 使用普通函数

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 定义比较函数
bool compareAsc(int a, int b) {
    return a < b;  // 升序: 当a<b时返回true
}

bool compareDesc(int a, int b) {
    return a > b;  // 降序: 当a>b时返回true
}

int main() {
    vector<int> arr = {5, 2, 8, 1, 9};
    
    sort(arr.begin(), arr.end(), compareAsc);   // 升序
    sort(arr.begin(), arr.end(), compareDesc);  // 降序
    
    return 0;
}
```

**注意事项:**
- 比较函数必须返回 `bool` 类型
- 返回 `true` 表示第一个参数应该排在第二个参数**前面**
- 函数必须满足**严格弱序**(strict weak ordering)关系

### 2. 使用 Lambda 表达式 (推荐)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr = {5, 2, 8, 1, 9};
    
    // Lambda 升序
    sort(arr.begin(), arr.end(), 
        [](int a, int b) {
        return a < b;
    });
    
    // Lambda 降序
    sort(arr.begin(), arr.end(), 
        [](int a, int b) {
        return a > b;
    });
    
    // 按绝对值排序
    sort(arr.begin(), arr.end(), 
        [](int a, int b) {
        return abs(a) < abs(b);
    });
    
    return 0;
}
```

**Lambda 表达式优点:**
- 代码简洁,就地定义
- 可以捕获外部变量
- 现代C++推荐写法

### 3. 使用函数对象(仿函数)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 定义函数对象
struct CompareAsc {
    bool operator()(int a, int b) const {
        return a < b;
    }
};

struct CompareDesc {
    bool operator()(int a, int b) const {
        return a > b;
    }
};

// 带状态的函数对象
struct CompareByModulo {
    int mod;
    CompareByModulo(int m) : mod(m) {}
    
    bool operator()(int a, int b) const {
        return (a % mod) < (b % mod);
    }
};

int main() {
    vector<int> arr = {5, 2, 8, 1, 9};
    
    sort(arr.begin(), arr.end(), CompareAsc());
    sort(arr.begin(), arr.end(), CompareDesc());
    sort(arr.begin(), arr.end(), CompareByModulo(3)); // 按模3余数排序
    
    return 0;
}
```

---

## 常见排序场景

### 1. 结构体排序

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

struct Student {
    string name;
    int age;
    double score;
};

int main() {
    vector<Student> students = {
        {"Alice", 20, 85.5},
        {"Bob", 19, 92.0},
        {"Charlie", 20, 88.0},
        {"David", 19, 92.0}
    };
    
    // 按年龄升序
    sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
        return a.age < b.age;
    });
    
    // 按分数降序
    sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
        return a.score > b.score;
    });
    
    // 多条件排序: 先按分数降序,分数相同按年龄升序
    sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
        if (a.score != b.score) {
            return a.score > b.score;  // 分数降序
        }
        return a.age < b.age;  // 年龄升序
    });
    
    // 多条件排序: 使用 tie (C++11)
    sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
        return tie(b.score, a.age) < tie(a.score, b.age);
        // b.score在前表示降序, a.age在前表示升序
    });
    
    return 0;
}
```

### 2. 二维数组/vector 排序

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<vector<int>> points = {
        {3, 4},
        {1, 2},
        {5, 1},
        {2, 3}
    };
    
    // 按第一个元素升序
    sort(points.begin(), points.end(), [](const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0];
    });
    
    // 按第二个元素降序
    sort(points.begin(), points.end(), [](const vector<int>& a, const vector<int>& b) {
        return a[1] > b[1];
    });
    
    // 按距离原点的距离排序
    sort(points.begin(), points.end(), [](const vector<int>& a, const vector<int>& b) {
        return a[0]*a[0] + a[1]*a[1] < b[0]*b[0] + b[1]*b[1];
    });
    
    // 先按x坐标,再按y坐标
    sort(points.begin(), points.end(), [](const vector<int>& a, const vector<int>& b) {
        if (a[0] != b[0]) return a[0] < b[0];
        return a[1] < b[1];
    });
    
    return 0;
}
```

### 3. pair 排序

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
using namespace std;

int main() {
    vector<pair<int, int>> pairs = {
        {3, 4},
        {1, 2},
        {3, 1},
        {1, 5}
    };
    
    // pair默认排序: 先按first,再按second (都是升序)
    sort(pairs.begin(), pairs.end());
    // 结果: (1,2), (1,5), (3,1), (3,4)
    
    // 按second降序,first升序
    sort(pairs.begin(), pairs.end(), [](const pair<int,int>& a, const pair<int,int>& b) {
        if (a.second != b.second) return a.second > b.second;
        return a.first < b.first;
    });
    
    // 只按second排序
    sort(pairs.begin(), pairs.end(), [](const pair<int,int>& a, const pair<int,int>& b) {
        return a.second < b.second;
    });
    
    return 0;
}
```

### 4. 字符串排序

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

int main() {
    vector<string> words = {"apple", "Banana", "cherry", "Date"};
    
    // 默认排序(字典序,区分大小写)
    sort(words.begin(), words.end());
    // 结果: Banana, Date, apple, cherry
    
    // 按长度排序
    sort(words.begin(), words.end(), [](const string& a, const string& b) {
        return a.length() < b.length();
    });
    
    // 不区分大小写排序
    sort(words.begin(), words.end(), [](const string& a, const string& b) {
        string a_lower = a, b_lower = b;
        transform(a_lower.begin(), a_lower.end(), a_lower.begin(), ::tolower);
        transform(b_lower.begin(), b_lower.end(), b_lower.begin(), ::tolower);
        return a_lower < b_lower;
    });
    
    // 按字符串中的数字排序
    vector<string> files = {"file10.txt", "file2.txt", "file1.txt"};
    sort(files.begin(), files.end(), [](const string& a, const string& b) {
        int num_a = stoi(a.substr(4, a.find('.') - 4));
        int num_b = stoi(b.substr(4, b.find('.') - 4));
        return num_a < num_b;
    });
    
    return 0;
}
```

### 5. 指针排序

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Node {
    int value;
    Node(int v) : value(v) {}
};

int main() {
    vector<Node*> nodes;
    nodes.push_back(new Node(5));
    nodes.push_back(new Node(2));
    nodes.push_back(new Node(8));
    
    // 按指针指向的值排序
    sort(nodes.begin(), nodes.end(), [](Node* a, Node* b) {
        return a->value < b->value;
    });
    
    // 清理内存
    for (auto node : nodes) {
        delete node;
    }
    
    return 0;
}
```

### 6. 自定义类型排序(重载运算符)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Student {
public:
    string name;
    int score;
    
    Student(string n, int s) : name(n), score(s) {}
    
    // 重载 < 运算符(用于默认排序)
    bool operator<(const Student& other) const {
        return score < other.score;  // 按分数升序
    }
    
    // 重载 > 运算符
    bool operator>(const Student& other) const {
        return score > other.score;
    }
};

int main() {
    vector<Student> students;
    students.emplace_back("Alice", 85);
    students.emplace_back("Bob", 92);
    students.emplace_back("Charlie", 78);
    
    // 使用重载的 < 运算符(默认排序)
    sort(students.begin(), students.end());
    
    // 使用 greater(需要重载 > 运算符)
    sort(students.begin(), students.end(), greater<Student>());
    
    return 0;
}
```

---

## stable_sort() 稳定排序

### 什么是稳定排序?
稳定排序保证相等元素的相对顺序在排序后保持不变。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Student {
    string name;
    int score;
};

int main() {
    vector<Student> students = {
        {"Alice", 85},
        {"Bob", 90},
        {"Charlie", 85},
        {"David", 90}
    };
    
    // 使用 sort (不稳定)
    sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
        return a.score < b.score;
    });
    // Alice和Charlie的顺序可能改变
    // Bob和David的顺序可能改变
    
    // 使用 stable_sort (稳定)
    stable_sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
        return a.score < b.score;
    });
    // Alice一定在Charlie前面
    // Bob一定在David前面
    
    return 0;
}
```

### 多次稳定排序实现复杂排序

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Student {
    string name;
    int age;
    double score;
};

int main() {
    vector<Student> students = {
        {"Alice", 20, 85.5},
        {"Bob", 19, 92.0},
        {"Charlie", 20, 88.0},
        {"David", 19, 92.0}
    };
    
    // 先按次要条件排序,再按主要条件排序
    // 最终效果: 先按分数降序,分数相同按年龄升序
    
    stable_sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
        return a.age < b.age;  // 次要条件: 年龄升序
    });
    
    stable_sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
        return a.score > b.score;  // 主要条件: 分数降序
    });
    
    return 0;
}
```

---

## partial_sort() 部分排序

### 功能说明
`partial_sort` 只对前 k 个元素排序,比完全排序更高效。

### 函数原型
```cpp
template<class RandomIt>
void partial_sort(RandomIt first, RandomIt middle, RandomIt last);

template<class RandomIt, class Compare>
void partial_sort(RandomIt first, RandomIt middle, RandomIt last, Compare comp);
```

### 使用示例

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    // 只排序前3个最小的元素
    partial_sort(arr.begin(), arr.begin() + 3, arr.end());
    // 结果: 1, 2, 3, ?, ?, ?, ?, ?, ? (后面的顺序不确定)
    
    // 前3个最大的元素(降序)
    partial_sort(arr.begin(), arr.begin() + 3, arr.end(), greater<int>());
    // 结果: 9, 8, 7, ?, ?, ?, ?, ?, ?
    
    return 0;
}
```

### 应用场景: Top K 问题

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 找出分数最高的前3名学生
struct Student {
    string name;
    double score;
};

int main() {
    vector<Student> students = {
        {"Alice", 85.5},
        {"Bob", 92.0},
        {"Charlie", 88.0},
        {"David", 79.5},
        {"Eve", 95.0}
    };
    
    // 找出分数最高的前3名
    partial_sort(students.begin(), students.begin() + 3, students.end(),
        [](const Student& a, const Student& b) {
            return a.score > b.score;
        });
    
    cout << "前3名:" << endl;
    for (int i = 0; i < 3; i++) {
        cout << students[i].name << ": " << students[i].score << endl;
    }
    
    return 0;
}
```

---

## 其他排序算法

### 1. nth_element() - 第n个元素

找出第n小(或大)的元素,左边的元素都不大于它,右边的元素都不小于它。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    // 找出第5小的元素(索引为4)
    nth_element(arr.begin(), arr.begin() + 4, arr.end());
    cout << "第5小的元素: " << arr[4] << endl;  // 5
    
    // 找出中位数
    int n = arr.size();
    nth_element(arr.begin(), arr.begin() + n/2, arr.end());
    cout << "中位数: " << arr[n/2] << endl;
    
    return 0;
}
```

### 2. is_sorted() - 判断是否已排序

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr1 = {1, 2, 3, 4, 5};
    vector<int> arr2 = {1, 3, 2, 4, 5};
    
    cout << is_sorted(arr1.begin(), arr1.end()) << endl;  // 1 (true)
    cout << is_sorted(arr2.begin(), arr2.end()) << endl;  // 0 (false)
    
    // 判断是否降序
    vector<int> arr3 = {5, 4, 3, 2, 1};
    cout << is_sorted(arr3.begin(), arr3.end(), greater<int>()) << endl;  // 1
    
    return 0;
}
```

### 3. is_sorted_until() - 找到第一个未排序的位置

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 5, 4, 6};
    
    auto it = is_sorted_until(arr.begin(), arr.end());
    if (it != arr.end()) {
        cout << "第一个未排序的元素索引: " << (it - arr.begin()) << endl;  // 4
        cout << "元素值: " << *it << endl;  // 4
    }
    
    return 0;
}
```

---

## 性能优化建议

### 1. 选择合适的排序算法

```cpp
// 场景1: 只需要前k个元素
vector<int> arr(10000);
partial_sort(arr.begin(), arr.begin() + 10, arr.end());  // O(n log k)
// 比完全排序快: sort(arr.begin(), arr.end());  // O(n log n)

// 场景2: 只需要第k个元素
nth_element(arr.begin(), arr.begin() + 10, arr.end());  // O(n)

// 场景3: 需要保持稳定性
stable_sort(arr.begin(), arr.end());  // 稳定但较慢

// 场景4: 一般排序
sort(arr.begin(), arr.end());  // 最快但不稳定
```

### 2. 避免不必要的复制

```cpp
// 不好: 传值,有复制开销
sort(students.begin(), students.end(), 
    [](Student a, Student b) {  // 值传递
        return a.score < b.score;
    });

// 好: 传引用,避免复制
sort(students.begin(), students.end(), 
    [](const Student& a, const Student& b) {  // 引用传递
        return a.score < b.score;
    });
```

### 3. 使用内联比较

```cpp
// 对于简单类型,直接比较最快
sort(arr.begin(), arr.end());  // 使用默认 <
sort(arr.begin(), arr.end(), greater<int>());  // 使用 STL 函数对象

// 对于复杂逻辑,使用 Lambda
sort(students.begin(), students.end(), 
    [](const Student& a, const Student& b) {
        return a.score > b.score;
    });
```

### 4. 预分配空间

```cpp
vector<int> result;
result.reserve(arr.size());  // 预分配空间避免多次重新分配
// ... 填充数据
sort(result.begin(), result.end());
```

---

## 常见陷阱和注意事项

### 1. 严格弱序要求

**错误示例:**
```cpp
// 错误: 违反严格弱序(不能用 <=)
sort(arr.begin(), arr.end(), [](int a, int b) {
    return a <= b;  // ❌ 错误!
});
```

**正确示例:**
```cpp
// 正确: 使用 <
sort(arr.begin(), arr.end(), [](int a, int b) {
    return a < b;  // ✅ 正确
});
```

**严格弱序要求:**
- 不可反身: `comp(a, a)` 必须为 `false`
- 非对称性: 如果 `comp(a, b)` 为 `true`,则 `comp(b, a)` 必须为 `false`
- 传递性: 如果 `comp(a, b)` 和 `comp(b, c)` 都为 `true`,则 `comp(a, c)` 也必须为 `true`

### 2. 浮点数比较

```cpp
#include <cmath>

// 不好: 直接比较浮点数
sort(arr.begin(), arr.end(), [](double a, double b) {
    return a < b;  // 可能因为精度问题出错
});

// 好: 考虑精度
const double EPS = 1e-9;
sort(arr.begin(), arr.end(), [](double a, double b) {
    return a < b - EPS;  // 考虑浮点数精度
});
```

### 3. 空容器处理

```cpp
vector<int> arr;  // 空容器
sort(arr.begin(), arr.end());  // ✅ 安全,不会出错

if (!arr.empty()) {  // 最佳实践: 先检查
    sort(arr.begin(), arr.end());
}
```

### 4. 迭代器失效

```cpp
vector<int> arr = {5, 2, 8, 1, 9};
auto it = arr.begin() + 2;  // 指向 8

sort(arr.begin(), arr.end());

// ❌ 错误: sort后迭代器可能失效
cout << *it << endl;  // 未定义行为

// ✅ 正确: 重新获取迭代器
it = arr.begin() + 2;
cout << *it << endl;
```

### 5. 自定义类型必须可复制

```cpp
struct NonCopyable {
    int value;
    NonCopyable(int v) : value(v) {}
    NonCopyable(const NonCopyable&) = delete;  // 禁止拷贝
    NonCopyable& operator=(const NonCopyable&) = delete;
};

vector<NonCopyable> arr;
// sort(arr.begin(), arr.end());  // ❌ 编译错误

// 解决方案: 使用指针或智能指针
vector<unique_ptr<NonCopyable>> arr2;
sort(arr2.begin(), arr2.end(), [](const auto& a, const auto& b) {
    return a->value < b->value;
});
```

### 6. Lambda 捕获外部变量

```cpp
int threshold = 50;

// 按值捕获(推荐用于简单类型)
sort(arr.begin(), arr.end(), [threshold](int a, int b) {
    return (a > threshold) < (b > threshold);
});

// 按引用捕获(注意生命周期)
sort(arr.begin(), arr.end(), [&threshold](int a, int b) {
    return (a > threshold) < (b > threshold);
});

// 捕获所有外部变量
sort(arr.begin(), arr.end(), [=](int a, int b) {  // 按值捕获所有
    return a < b;
});

sort(arr.begin(), arr.end(), [&](int a, int b) {  // 按引用捕获所有
    return a < b;
});
```

---

## 实战示例

### 示例1: LeetCode 风格 - 区间排序

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 合并区间问题
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    if (intervals.empty()) return {};
    
    // 按区间起点排序
    sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0];
    });
    
    vector<vector<int>> result;
    result.push_back(intervals[0]);
    
    for (int i = 1; i < intervals.size(); i++) {
        if (intervals[i][0] <= result.back()[1]) {
            result.back()[1] = max(result.back()[1], intervals[i][1]);
        } else {
            result.push_back(intervals[i]);
        }
    }
    
    return result;
}
```

### 示例2: 自定义优先级排序

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

struct Task {
    string name;
    int priority;  // 1-5, 5最高
    int duration;  // 分钟
};

int main() {
    vector<Task> tasks = {
        {"写报告", 3, 120},
        {"回邮件", 5, 30},
        {"开会", 4, 60},
        {"写代码", 3, 180}
    };
    
    // 排序规则: 优先级高的先做,优先级相同时短任务先做
    sort(tasks.begin(), tasks.end(), [](const Task& a, const Task& b) {
        if (a.priority != b.priority) {
            return a.priority > b.priority;  // 优先级降序
        }
        return a.duration < b.duration;  // 时长升序
    });
    
    cout << "任务执行顺序:" << endl;
    for (const auto& task : tasks) {
        cout << task.name << " (优先级:" << task.priority 
             << ", 时长:" << task.duration << "分钟)" << endl;
    }
    
    return 0;
}
```

### 示例3: 多维排序

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <tuple>
using namespace std;

struct Person {
    string name;
    int age;
    double salary;
    string department;
};

int main() {
    vector<Person> people = {
        {"Alice", 30, 5000, "IT"},
        {"Bob", 25, 6000, "HR"},
        {"Charlie", 30, 5500, "IT"},
        {"David", 25, 6000, "IT"}
    };
    
    // 复杂排序: 部门 -> 年龄 -> 工资(