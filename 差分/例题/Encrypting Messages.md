https://codeforces.com/contest/177/problem/D2

## **D2. Encrypting Messages**

聪明的海狸（Smart Beaver）发明了一种新的消息加密方法，现在他想检查它的性能。手动检查既漫长又枯燥，因此他决定请 ABBYY Cup 的参赛者帮忙。

一条消息由 n 个整数构成：a₁, a₂, …, aₙ。
 加密使用一个长度为 m 的密钥序列：b₁, b₂, …, bₘ（且 m ≤ n）。
 消息中每个数字以及密钥中的每个数字都在 **0 到 c−1** 之间（包含两端）。
 **所有计算都在模 c 下进行（也就是 mod c）。**

------

### **加密过程**

加密一共会进行 **n − m + 1 步**。

第 1 步：
 对消息中的 a₁, a₂, …, aₘ
 分别加上密钥的 b₁, b₂, …, bₘ。

第 2 步：
 对消息中的 a₂, a₃, …, aₘ₊₁（注意这些数是前一步已经被修改过的）
 分别加上密钥 b₁, b₂, …, bₘ。

依此类推：
 第 i 步，对消息中的
 aᵢ, aᵢ₊₁, …, aᵢ₊ₘ₋₁
 分别加上 b₁, b₂, …, bₘ。

最终加密的结果就是在完成所有 n − m + 1 步之后的序列 a₁, a₂, …, aₙ。

------

### **输入格式**

第一行：三个整数 n、m、c。

第二行：n 个整数 aᵢ（0 ≤ aᵢ < c）—— 原始消息。

第三行：m 个整数 bᵢ（0 ≤ bᵢ < c）—— 加密密钥。

------

### **数据范围**

**30 分：**

1 ≤ m ≤ n ≤ 10³
 1 ≤ c ≤ 10³

**100 分：**

1 ≤ m ≤ n ≤ 10⁵
 1 ≤ c ≤ 10³

------

### **输出格式**

输出 n 个整数，用空格分隔 —— 加密后的消息序列。

------

### **样例 1 解释**

输入：

```
4 3 2
1 1 1 1
1 1 1
```

第一步后：
 (1,1,1) + (1,1,1) = (0,0,0) mod 2
 消息变成：**(0,0,0,1)**

第二步：
 对 (0,0,1) 加上 (1,1,1)：
 → (1,1,0) mod 2
 消息变成：**(0,1,1,0)**











## 解题思路

1. 先处理加法部分再取模
2. 使用**差分数组**进行优化

#### 核心观察

**关键问题**：每个位置 a[k] 最终被加了多少？

让我们**换个角度思考**：不看每一步做什么，而是看每个 b[j] 对哪些位置产生了影响。

#### 推导过程

**第 i 步的操作**：

```
a[i+0] += b[0]
a[i+1] += b[1]
a[i+2] += b[2]
...
a[i+j] += b[j]
...
a[i+m-1] += b[m-1]
```

**反过来看 b[j]**：

- 步骤 0：b[j] 加到 a[0+j] = a[j]
- 步骤 1：b[j] 加到 a[1+j] = a[j+1]
- 步骤 2：b[j] 加到 a[2+j] = a[j+2]
- ...
- 步骤 n-m：b[j] 加到 a[(n-m)+j]

**结论**：

> b[j] 会影响连续区间 **[j, j+(n-m)]**，每个位置恰好加一次 b[j]

#### 差分数组技巧

**问题**：如何高效地让区间 [L, R] 的所有元素都加 x？

**差分数组解法**：

```cpp
diff[L] += x;      // 标记"从L开始累加x"
diff[R+1] -= x;    // 标记"从R+1开始停止累加x"
```

**还原操作**（前缀和）：

```cpp
cumsum = 0;
for (int i = 0; i < n; i++) {
    cumsum += diff[i];
    a[i] += cumsum;  // cumsum 就是位置 i 应该累加的总值
}
```



## 代码实现

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, m, c;
    cin >> n >> m >> c;
    
    // 读取原始消息
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    
    // 读取加密密钥
    vector<int> b(m);
    for (int i = 0; i < m; i++) {
        cin >> b[i];
    }
    
    // 使用差分数组优化
    // diff[i] 表示位置 i 累计要加的值
    vector<long long> diff(n + 1, 0);
    
    // 对于每一步 i (从 0 到 n-m)
    // 需要让 a[i+j] 加上 b[j] (j 从 0 到 m-1)
    // 等价于让 a[i+j] 加上 b[j] * (从步骤 max(0, i+j-m+1) 到 min(i, n-m) 的次数)
    
    // 更简单的思路：每个位置 a[k] 会被加上多少次 b[j]？
    // 当 k = i + j 时，在第 i 步会被加上 b[j]
    // 即 i = k - j，需要 0 <= i <= n-m 且 0 <= j < m
    // 即 max(0, k-m+1) <= i <= min(k, n-m)
    
    for (int j = 0; j < m; j++) {
        // b[j] 会在哪些步骤中被加到哪些位置？
        // 第 i 步时，b[j] 被加到 a[i+j]
        // 所以 b[j] 会影响 a[j], a[j+1], ..., a[j+(n-m)]
        // 使用差分：在 j 处 +b[j]，在 j+(n-m)+1 处 -b[j]
        diff[j] += b[j];
        diff[j + (n - m) + 1] -= b[j];
    }
    
    // 还原差分数组，得到每个位置被加的总次数
    long long cumsum = 0;
    for (int i = 0; i < n; i++) {
        cumsum += diff[i];
        a[i] = (a[i] + cumsum) % c;
        // 处理负数情况
        if (a[i] < 0) a[i] += c;
    }
    
    // 输出加密后的结果
    for (int i = 0; i < n; i++) {
        if (i > 0) cout << " ";
        cout << a[i];
    }
    cout << endl;
    
    return 0;
}
```

