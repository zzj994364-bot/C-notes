# 高精度 (High Precision Arithmetic)

## 基础

高精度算法，也称大数运算（Bignum），是处理超出标准数据类型（如 long long）表示范围的极大整数的一系列技巧。当一个整数的位数非常多（例如，超过20位，甚至达到成百上千位）时，就需要使用高精度算法。

高精度算法通过类（Class）封装，可以极大地提升代码的可读性、可重用性和易用性。通过重载 C++ 的运算符（如 `+`, `-`, `*`, `<`, `>>` 等），我们可以让自定义的大数类的行为尽可能地接近内置的整数类型。

**核心思想与表示**:
* **表示**: 通常使用数组或字符串来存储大数的每一位。最常见和方便的实现方式是使用 `vector<int>`，并将数字的**低位存储在向量的低索引处**（即倒序存储）。
    * 例如，数字 `12345` 可以表示为向量 `{5, 4, 3, 2, 1}`。
    * 这样做的好处是，在进行加法、乘法等运算时，进位总是从低索引向高索引传播，与数组的动态增长方向 `push_back` 一致，处理起来非常自然。
* **运算**: 所有算术运算（加、减、乘、除、求余）都通过**模拟人工竖式计算**的过程来实现。


**解决的问题与应用**:
1.  **超大整数的精确计算**: 当 `long long` 也无法存储计算结果时，高精度是唯一的选择。
      * 计算极大的阶乘，如 $100!$。
      * 计算斐波那契数列的第 $n$ 项（当 $n$ 很大时）。
      * 求解指数幂问题，如 $2^{1000}$。
2.  **组合数学**: 许多组合计数问题的结果非常大，需要用高精度来存储。
3.  **密码学**: 像 RSA 这样的公钥加密体系依赖于对极大整数（几百位甚至上千位）的运算。
4.  **特定算法竞赛题目**: 直接要求对大数进行输入、处理和输出。

时间/空间复杂度（设两个大数 A 和 B 的位数分别为 $N$ 和 $M$）：

  * **构造函数**: 从字符串构造: $O(N)$
  * **比较**: $O(\max(N, M))$
  * **加/减法**: $O(\max(N, M))$
  * **乘法**:
      * 高精度乘以低精度: 时间 $O(N)$，空间 $O(N)$。
      * 高精度乘以高精度（朴素）: 时间 $O(N \cdot M)$，空间 $O(N+M)$。
  * **除法**:
      * 高精度除以低精度: 时间 $O(N)$，空间 $O(N)$。

## 算法的流程

### 高精度加法流程

1.  从最低位（索引0）开始，逐位将两个数的对应位相加，并加上来自前一位的进位 `carry`。
2.  将和的个位数（`sum % 10`）存入结果向量的当前位。
3.  将和的十位数（`sum / 10`）作为新的 `carry` 传递给下一位。
4.  遍历完两个数的所有位后，如果 `carry` 仍大于0，将其作为最高位添加到结果向量中。

### 高精度减法流程 (A - B, 假设 A \>= B)

1.  从最低位（索引0）开始，逐位用被减数 `A` 的对应位减去减数 `B` 的对应位，并减去来自前一位的借位 `borrow`。
2.  如果结果为负，则向高位借 1（相当于给当前位加上10），并将 `borrow` 设为 1。否则 `borrow` 为 0。
3.  将结果存入结果向量的当前位。
4.  遍历结束后，移除结果向量尾部多余的0（例如 `123 - 120 = 3`，而不是 `003`）。

### 其他
略

## 算法模板

这是一个功能较全面的 `BigInt` 类的模板，实现了构造、输入输出、比较以及核心的加、减、乘、除、求余运算。

```cpp
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>

// 使用 vector<int> 作为大数的基本类型
using BigIntBase = vector<int>;

class BigInt {
private:
    BigIntBase digits;
    bool is_negative = false;

    // 移除前导（vector尾部）的0
    void remove_leading_zeros() {
        while (digits.size() > 1 && digits.back() == 0) {
            digits.pop_back();
        }
        if (digits.size() == 1 && digits[0] == 0) {
            is_negative = false; // 0 是非负数
        }
    }

public:
    // --- 构造函数 ---
    BigInt(long long n = 0) {
        if (n < 0) {
            is_negative = true;
            n = -n;
        }
        if (n == 0) {
            digits.push_back(0);
            return;
        }
        while (n > 0) {
            digits.push_back(n % 10);
            n /= 10;
        }
    }

    BigInt(const string& s) {
        if (s.empty() || (s.length() == 1 && s[0] == '0')) {
            digits.push_back(0);
            return;
        }
        int start = 0;
        if (s[0] == '-') {
            is_negative = true;
            start = 1;
        }
        for (int i = s.length() - 1; i >= start; --i) {
            digits.push_back(s[i] - '0');
        }
        remove_leading_zeros();
    }

    // --- I/O 操作 (要写成友元函数) ---
    friend ostream& operator<<(ostream& os, const BigInt& num) {
        if (num.is_negative) {
            os << '-';
        }
        for (int i = num.digits.size() - 1; i >= 0; --i) {
            os << num.digits[i];
        }
        return os;
    }

    friend istream& operator>>(istream& is, BigInt& num) {
        string s;
        is >> s;
        num = BigInt(s);
        return is;
    }
    
    // --- 比较运算符 ---
    bool operator<(const BigInt& other) const {
        if (is_negative != other.is_negative) {
            return is_negative; // 负数小于正数
        }
        if (is_negative) { // 两个都是负数
            // 比较绝对值，绝对值大的反而小
            if (digits.size() != other.digits.size()) {
                return digits.size() > other.digits.size();
            }
            for (int i = digits.size() - 1; i >= 0; --i) {
                if (digits[i] != other.digits[i]) {
                    return digits[i] > other.digits[i];
                }
            }
        } else { // 两个都是正数
            if (digits.size() != other.digits.size()) {
                return digits.size() < other.digits.size();
            }
            for (int i = digits.size() - 1; i >= 0; --i) {
                if (digits[i] != other.digits[i]) {
                    return digits[i] < other.digits[i];
                }
            }
        }
        return false; // 相等
    }
    // 其他比较运算符可以基于 < 实现
    bool operator>(const BigInt& other) const { return other < *this; }
    bool operator<=(const BigInt& other) const { return !(*this > other); }
    bool operator>=(const BigInt& other) const { return !(*this < other); }
    bool operator==(const BigInt& other) const { return !(*this < other) && !(*this > other); }
    bool operator!=(const BigInt& other) const { return !(*this == other); }

    // --- 算术运算符 ---
    // 高精度加法
    BigInt operator+(const BigInt& other) const {
        // 符号不同时，转为减法
        if (is_negative != other.is_negative) {
            // this - (-other) 或 other - (-this)
            return *this - (-other);
        }
        BigInt result;
        result.digits.clear();
        result.is_negative = is_negative;
        int carry = 0;
        for (int i = 0; i < digits.size() || i < other.digits.size() || carry; ++i) {
            if (i < digits.size()) carry += digits[i];
            if (i < other.digits.size()) carry += other.digits[i];
            result.digits.push_back(carry % 10);
            carry /= 10;
        }
        return result;
    }

    // 一元负号
    BigInt operator-() const {
        BigInt result = *this;
        if (result.digits.size() == 1 && result.digits[0] == 0) {
            return result;
        }
        result.is_negative = !is_negative;
        return result;
    }

    // 高精度减法
    BigInt operator-(const BigInt& other) const {
        // 符号不同时，转为加法
        if (is_negative != other.is_negative) {
            // this + (-other)
            return *this + (-other);
        }
        // 比较绝对值大小
        BigInt a = *this, b = other;
        a.is_negative = b.is_negative = false;
        if (a < b) return -(b - a);
        
        BigInt result;
        result.digits.clear();
        int borrow = 0;
        for (int i = 0; i < a.digits.size(); ++i) {
            int current_digit = a.digits[i] - borrow;
            if (i < b.digits.size()) current_digit -= b.digits[i];
            
            if (current_digit < 0) {
                borrow = 1;
                result.digits.push_back(current_digit + 10);
            } else {
                borrow = 0;
                result.digits.push_back(current_digit);
            }
        }
        result.remove_leading_zeros();
        result.is_negative = is_negative;
        return result;
    }

    // 高精度乘法 (大数 * 大数)
    BigInt operator*(const BigInt& other) const {
        BigInt result;
        result.digits.resize(digits.size() + other.digits.size(), 0);
        
        for (int i = 0; i < digits.size(); ++i) {
            for (int j = 0; j < other.digits.size(); ++j) {
                result.digits[i + j] += digits[i] * other.digits[j];
            }
        }

        for (int i = 0; i < result.digits.size() - 1; ++i) {
            result.digits[i + 1] += result.digits[i] / 10;
            result.digits[i] %= 10;
        }
        
        result.remove_leading_zeros();
        result.is_negative = is_negative != other.is_negative;
        return result;
    }

    // 高精度 * 低精度
    BigInt operator*(long long b) const {
        if (b == 0) return BigInt(0);
        BigInt result;
        result.digits.clear();
        result.is_negative = is_negative != (b < 0);
        if (b < 0) b = -b;

        long long carry = 0;
        for (int i = 0; i < digits.size() || carry; ++i) {
            if (i < digits.size()) carry += digits[i] * b;
            result.digits.push_back(carry % 10);
            carry /= 10;
        }
        result.remove_leading_zeros();
        return result;
    }

    // 高精度 / 低精度
    BigInt operator/(long long b) const {
        if (b == 0) throw std::runtime_error("Division by zero");
        BigInt result;
        result.digits.clear();
        result.is_negative = is_negative != (b < 0);
        if (b < 0) b = -b;

        long long remainder = 0;
        for (int i = digits.size() - 1; i >= 0; --i) {
            remainder = remainder * 10 + digits[i];
            result.digits.push_back(remainder / b);
            remainder %= b;
        }
        reverse(result.digits.begin(), result.digits.end());
        result.remove_leading_zeros();
        return result;
    }

    // 高精度 % 低精度
    long long operator%(long long b) const {
        if (b == 0) throw std::runtime_error("Division by zero");
        if (b < 0) b = -b;
        long long remainder = 0;
        for (int i = digits.size() - 1; i >= 0; --i) {
            remainder = (remainder * 10 + digits[i]) % b;
        }
        return is_negative ? -remainder : remainder;
    }
};
```





### Gpt版：

```cpp
#include <bits/stdc++.h>
using namespace std;

struct BigInt {
    //支持cin操作
    friend istream& operator>>(istream& is, BigInt& x) {
        string s;
        is >> s;
        x.parse(s);
        return is;
    }
    
    vector<int> d;   // 低位在前
    bool neg = false;

    BigInt(long long x = 0) { *this = x; }
    BigInt(const string& s) { parse(s); }

    // 从 long long
    BigInt& operator=(long long x) {
        d.clear();
        if (x < 0) neg = true, x = -x;
        else neg = false;
        if (x == 0) d.push_back(0);
        while (x) {
            d.push_back(x % 10);
            x /= 10;
        }
        return *this;
    }

    // 从字符串
    void parse(string s) {
        d.clear();
        neg = false;
        if (s[0] == '-') {
            neg = true;
            s = s.substr(1);
        }
        for (int i = s.size() - 1; i >= 0; i--)
            d.push_back(s[i] - '0');
        trim();
    }

    // 去掉前导 0
    void trim() {
        while (d.size() > 1 && d.back() == 0)
            d.pop_back();
        if (d.size() == 1 && d[0] == 0) neg = false;
    }

    // 比较绝对值
    static int absCmp(const BigInt& a, const BigInt& b) {
        if (a.d.size() != b.d.size())
            return a.d.size() < b.d.size() ? -1 : 1;
        for (int i = a.d.size() - 1; i >= 0; i--)
            if (a.d[i] != b.d[i])
                return a.d[i] < b.d[i] ? -1 : 1;
        return 0;
    }

    // BigInt 与 BigInt 比较
    bool operator<(const BigInt& o) const {
        if (neg != o.neg) return neg;
        int t = absCmp(*this, o);
        return neg ? t > 0 : t < 0;
    }
    bool operator>(const BigInt& o) const { return o < *this; }
    bool operator<=(const BigInt& o) const { return !(*this > o); }
    bool operator>=(const BigInt& o) const { return !(*this < o); }
    bool operator==(const BigInt& o) const { return neg == o.neg && d == o.d; }
    bool operator!=(const BigInt& o) const { return !(*this == o); }

    //===============================
    //  BigInt 与 long long / int 比较
    //===============================
    bool operator<(long long x) const { return *this < BigInt(x); }
    bool operator>(long long x) const { return BigInt(x) < *this; }
    bool operator<=(long long x) const { return !(*this > x); }
    bool operator>=(long long x) const { return !(*this < x); }
    bool operator==(long long x) const { return *this == BigInt(x); }
    bool operator!=(long long x) const { return !(*this == x); }

    friend bool operator<(long long x, const BigInt& b) { return BigInt(x) < b; }
    friend bool operator>(long long x, const BigInt& b) { return b < BigInt(x); }
    friend bool operator<=(long long x, const BigInt& b) { return !(x > b); }
    friend bool operator>=(long long x, const BigInt& b) { return !(x < b); }
    friend bool operator==(long long x, const BigInt& b) { return BigInt(x) == b; }
    friend bool operator!=(long long x, const BigInt& b) { return !(x == b); }

    //===============================

    // 加法（绝对值加）
    static BigInt absAdd(const BigInt& a, const BigInt& b) {
        BigInt c;
        c.neg = a.neg;
        int carry = 0;
        for (size_t i = 0; i < a.d.size() || i < b.d.size() || carry; i++) {
            int x = carry;
            if (i < a.d.size()) x += a.d[i];
            if (i < b.d.size()) x += b.d[i];
            c.d.push_back(x % 10);
            carry = x / 10;
        }
        return c;
    }

    // 减法（要求|a|>=|b|）
    static BigInt absSub(const BigInt& a, const BigInt& b) {
        BigInt c;
        c.neg = a.neg;
        int borrow = 0;
        for (size_t i = 0; i < a.d.size(); i++) {
            int x = a.d[i] - borrow - (i < b.d.size() ? b.d[i] : 0);
            if (x < 0) x += 10, borrow = 1;
            else borrow = 0;
            c.d.push_back(x);
        }
        c.trim();
        return c;
    }

    // + 运算
    BigInt operator+(const BigInt& o) const {
        if (neg == o.neg)
            return absAdd(*this, o);
        if (absCmp(*this, o) >= 0)
            return absSub(*this, o);
        BigInt c = absSub(o, *this);
        c.neg = o.neg;
        return c;
    }

    // - 运算
    BigInt operator-(const BigInt& o) const {
        if (neg != o.neg)
            return absAdd(*this, o);
        if (absCmp(*this, o) >= 0)
            return absSub(*this, o);
        BigInt c = absSub(o, *this);
        c.neg = !o.neg;
        return c;
    }

    // 乘法
    BigInt operator*(const BigInt& o) const {
        BigInt c;
        c.d.assign(d.size() + o.d.size(), 0);
        c.neg = neg ^ o.neg;
        for (size_t i = 0; i < d.size(); i++) {
            int carry = 0;
            for (size_t j = 0; j < o.d.size() || carry; j++) {
                long long cur = c.d[i + j] + (long long)d[i] * (j < o.d.size() ? o.d[j] : 0) + carry;
                c.d[i + j] = cur % 10;
                carry = cur / 10;
            }
        }
        c.trim();
        return c;
    }

    // 除法（朴素）
    BigInt operator/(const BigInt& o) const {
        BigInt a = *this, b = o;
        a.neg = b.neg = false;

        BigInt res, cur;
        res.d.assign(a.d.size(), 0);

        for (int i = a.d.size() - 1; i >= 0; i--) {
            cur.d.insert(cur.d.begin(), a.d[i]);
            cur.trim();

            int x = 0, l = 0, r = 9;
            while (l <= r) {
                int m = (l + r) / 2;
                BigInt t = b * m;
                if (absCmp(t, cur) <= 0) x = m, l = m + 1;
                else r = m - 1;
            }
            res.d[i] = x;
            cur = cur - b * x;
        }
        res.neg = neg ^ o.neg;
        res.trim();
        return res;
    }

    // 与 int 的加减乘除
    BigInt operator+(int x) const { return *this + BigInt(x); }
    BigInt operator-(int x) const { return *this - BigInt(x); }
    BigInt operator*(int x) const { return *this * BigInt(x); }
    BigInt operator/(int x) const { return *this / BigInt(x); }

    // 输出
    friend ostream& operator<<(ostream& os, const BigInt& x) {
        if (x.neg) os << "-";
        for (int i = x.d.size() - 1; i >= 0; i--)
            os << x.d[i];
        return os;
    }
};

```





### 用法

```cpp
int main() {
    //赋值
    BigInt a("99999999999999999999999");
    BigInt b(123456);

    //支持加减乘除
    cout << a + b << "\n";
    cout << a - b << "\n";
    cout << a * b << "\n";
    cout << a / 2 << "\n";
    
    //支持大小比较
    if (a > 1234567890123LL) cout << "ok\n";
    if (0 < a) cout << "positive\n";
    if (a != 0) cout << "nonzero\n";
    if (a >= -100) cout << "yes\n";
}

int main() {
    //cin操作
    BigInt a, b;
    cin >> a >> b;
    
    
}

```

