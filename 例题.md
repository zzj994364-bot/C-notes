# 稳定循环 （ai写，未整理） 题单28

## 1. 算法（或技巧）用于解决什么问题（重要）

稳定循环主要用于 **序列/队列模拟类问题**：

- 在模拟一段时间后，数据结构进入 **稳定状态**（某些部分固定，某些部分周期性重复）。

- 题目往往要求我们回答第 m 步或很大的 m（例如 10^18），直接模拟肯定超时。

- 我们利用 **循环节** 的性质，把问题从「逐步模拟」优化为 **O(1) 查询**。

典型应用：

- CF 1179A *Valeriy and Deque*（操作次数可达 10^18）。

- 类似“约瑟夫环”“循环队列”等周期性问题。

## 2. 做题时，怎么和这个算法（或技巧）联系起来（切入点）

切入点：

1. 模拟前几步，观察变化是否出现 **固定头元素** 或 **周期性轮换**。

2. 如果发现状态开始重复，可以大胆猜测进入循环。

3. 注意循环长度通常和元素个数有关（如 n-1）。

经验判断：

- 题目数据范围里 m 很大（比如 10^18），而队列元素 n 较小（如 10^5），几乎可以断定需要找 **循环节**。

- 如果头部最大元素出现且保持不变，那就进入稳定循环了。

## 3. 时间、空间复杂度（重要）

- **预处理（找到稳定开始位置）**：O(n)
  
  - 因为最大值出现后就稳定，最多模拟 n 次。

- **回答查询**：
  
  - 每个查询 O(1)，用公式直接定位。

- **空间复杂度**：O(n)（存储队列）。

所以整体复杂度：

```cpp
O(n + q)
```

远小于暴力 O(m)，可应对 m = 10^18。

## 4. 算法（或技巧）的流程

1. **模拟过程直到稳定**：
   
   - 不断从队首取两个数 A 和 B，比较大小。
   
   - 较大数回到队首，较小数进入队尾。
   
   - 记录每一步取出的 (A, B)。
   
   - 当最大元素到达队首时，进入稳定状态。

2. **确定稳定循环的性质**：
   
   - 队首固定为最大值。
   
   - 队列其他 n-1 个元素循环移动。
   
   - 循环长度为 n-1。

3. **回答查询**：
   
   - 如果 m < stable_start，直接输出之前记录的答案。
   
   - 如果 m ≥ stable_start，利用公式计算：

```cpp
cycle_pos = ((m - stable_start) % (n - 1)) + 1;
A = dq[0];          // 最大值
B = dq[cycle_pos];  // 循环部分
```

## 5. 算法模板代码（带注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, q;
    cin >> n >> q;
    deque<int> dq(n);
    for (int i = 0; i < n; i++) cin >> dq[i];

    int max_val = *max_element(dq.begin(), dq.end());

    // 记录前 stable_start-1 步的结果
    vector<pair<int,int>> pre;
    int step = 0;

    while (dq.front() != max_val) {
        int A = dq.front(); dq.pop_front();
        int B = dq.front(); dq.pop_front();
        step++;

        pre.push_back({A, B});
        if (A > B) {
            dq.push_front(A);
            dq.push_back(B);
        } else {
            dq.push_front(B);
            dq.push_back(A);
        }
    }

    // 保存稳定后的队列状态
    vector<int> stable(dq.begin(), dq.end());
    int stable_start = step + 1;  // 从这一步开始稳定

    while (q--) {
        long long m; 
        cin >> m;
        if (m < stable_start) {
            cout << pre[m-1].first << " " << pre[m-1].second << "\n";
        } else {
            long long cycle_pos = ((m - stable_start) % (n - 1)) + 1;
            cout << stable[0] << " " << stable[cycle_pos] << "\n";
        }
    }
}
```

## 6. 心得（重要）

- **思想**：
  
  - 本质是“找到循环节”，用 **数学公式替代模拟**。
  
  - 队首最大值 → 稳定点 → 循环节长度 n-1。

- **技巧**：
  
  - 用 pre 保存稳定前的操作结果。
  
  - 用取模 % 定位到循环部分。
  
  - 注意偏移量 (m - stable_start)，再加 +1 保证索引从 1 开始。

- **对比**：
  
  - 类似 **约瑟夫环**：那里的循环是通过公式直接推。
  
  - 类似 **龟兔赛跑判环**：都是先找到循环节，再用数学简化。

- **关键点**：
  
  - 如果没观察到「最大值固定」这个现象，就很容易超时。
  
  - 切入点永远是：**数据范围 + 模拟特征**。